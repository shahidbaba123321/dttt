<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WorkWise Pro - Super Admin Dashboard</title>
    
    <!-- CSS Libraries -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
   /* Root Variables */
:root {
    --primary-color: #2563EB;
    --secondary-color: #1E40AF;
    --success-color: #059669;
    --warning-color: #D97706;
    --danger-color: #DC2626;
    --info-color: #2563EB;
    --dark-color: #111827;
    --light-color: #F3F4F6;
    --white: #FFFFFF;
    --sidebar-width: 280px;
    --header-height: 70px;
    --sidebar-bg: #1E293B;
    --body-bg: #F8FAFC;
    --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    --transition: all 0.3s ease;
}

/* Global Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
}

body {
    font-size: 14px;
    line-height: 1.6;
    color: var(--dark-color);
    background-color: var(--body-bg);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
    line-height: 1.3;
    color: var(--dark-color);
    margin-bottom: 0.5rem;
}

/* Sidebar Styles */
.sidebar {
    position: fixed;
    left: 0;
    top: 0;
    width: var(--sidebar-width);
    height: 100vh;
    background: var(--sidebar-bg);
    color: var(--white);
    overflow-y: auto;
    transition: var(--transition);
    z-index: 1000;
    box-shadow: 2px 0 8px rgba(0, 0, 0, 0.1);
}

.sidebar-header {
    padding: 1.5rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    background: rgba(0, 0, 0, 0.1);
}

.sidebar-header img {
    width: 40px;
    height: 40px;
    object-fit: contain;
}

.sidebar-header h2 {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--white);
    margin: 0;
}

.nav-menu {
    padding: 1rem 0;
}

.nav-item {
    padding: 0.25rem 1rem;
}

.nav-link {
    display: flex;
    align-items: center;
    padding: 0.875rem 1.5rem;
    color: rgba(255, 255, 255, 0.7);
    text-decoration: none;
    border-radius: 8px;
    margin: 0.25rem 0;
    transition: var(--transition);
}

.nav-link:hover {
    background: rgba(255, 255, 255, 0.1);
    color: var(--white);
    transform: translateX(5px);
}

.nav-link.active {
    background: var(--primary-color);
    color: var(--white);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.nav-link i {
    width: 20px;
    margin-right: 12px;
    font-size: 1.1rem;
}

/* Main Content Area */
.main-content {
    margin-left: var(--sidebar-width);
    padding: calc(var(--header-height) + 2rem) 2rem 2rem;
    min-height: 100vh;
    transition: var(--transition);
    background-color: var(--body-bg);
}

/* Header Styles */
.header {
    position: fixed;
    top: 0;
    left: var(--sidebar-width);
    right: 0;
    height: var(--header-height);
    background: var(--white);
    padding: 0 2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
    transition: var(--transition);
    z-index: 999;
}

.header-left {
    display: flex;
    align-items: center;
    gap: 1.5rem;
}

.menu-toggle {
    display: none;
    background: none;
    border: none;
    color: var(--dark-color);
    font-size: 1.25rem;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 8px;
    transition: var(--transition);
}

.menu-toggle:hover {
    background: var(--light-color);
}

.breadcrumb h2 {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--dark-color);
    margin: 0;
}
        /* Header Right Section */
.header-right {
    display: flex;
    align-items: center;
    gap: 1.5rem;
}

.header-actions {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.btn {
    padding: 0.625rem 1.25rem;
    border-radius: 8px;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition);
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    border: 1px solid transparent;
    font-size: 0.875rem;
}

.btn-primary {
    background: var(--primary-color);
    color: var(--white);
}

.btn-primary:hover {
    background: var(--secondary-color);
    transform: translateY(-1px);
    box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.2);
}

.btn-outline {
    background: transparent;
    border: 1px solid var(--primary-color);
    color: var(--primary-color);
}

.btn-outline:hover {
    background: var(--primary-color);
    color: var(--white);
    transform: translateY(-1px);
    box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.2);
}

.notification-bell {
    position: relative;
    padding: 0.5rem;
    cursor: pointer;
    color: var(--dark-color);
    transition: var(--transition);
}

.notification-bell:hover {
    color: var(--primary-color);
}

.notification-bell .badge {
    position: absolute;
    top: 0;
    right: 0;
    background: var(--danger-color);
    color: var(--white);
    font-size: 0.75rem;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid var(--white);
}

.user-profile {
    display: flex;
    align-items: center;
    gap: 1rem;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 8px;
    transition: var(--transition);
}

.user-profile:hover {
    background: var(--light-color);
}

.user-profile img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid rgba(0, 0, 0, 0.05);
}

.user-info {
    display: none;
}

/* Dashboard Container */
.dashboard-container {
    padding: 1.5rem 0;
}

/* Stats Section */
.stats-section {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
}

.stat-card {
    background: var(--white);
    padding: 1.5rem;
    border-radius: 12px;
    box-shadow: var(--card-shadow);
    display: flex;
    align-items: flex-start;
    gap: 1.25rem;
    transition: var(--transition);
    border: 1px solid rgba(0, 0, 0, 0.05);
}

.stat-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 12px -1px rgba(0, 0, 0, 0.1);
}

.stat-icon {
    width: 48px;
    height: 48px;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
}

.stat-info {
    flex: 1;
}

.stat-info h3 {
    font-size: 0.875rem;
    color: var(--dark-color);
    opacity: 0.8;
    margin-bottom: 0.5rem;
    font-weight: 500;
}

.stat-value {
    font-size: 1.75rem;
    font-weight: 600;
    color: var(--dark-color);
    margin-bottom: 0.5rem;
    line-height: 1;
}

.stat-change {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    font-weight: 500;
}

.stat-change.positive {
    color: var(--success-color);
}

.stat-change.negative {
    color: var(--danger-color);
}

/* Dashboard Grid */
.dashboard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 1.5rem;
}
        /* Dashboard Widget Styles */
.dashboard-widget {
    background: var(--white);
    border-radius: 12px;
    box-shadow: var(--card-shadow);
    transition: var(--transition);
    border: 1px solid rgba(0, 0, 0, 0.05);
    overflow: hidden;
}

.dashboard-widget:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 12px -1px rgba(0, 0, 0, 0.1);
}

.widget-header {
    padding: 1.25rem 1.5rem;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(0, 0, 0, 0.02);
}

.widget-header h3 {
    font-size: 1rem;
    font-weight: 600;
    color: var(--dark-color);
    margin: 0;
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.widget-header h3 i {
    color: var(--primary-color);
    font-size: 1.1rem;
}

.widget-actions {
    display: flex;
    gap: 0.5rem;
}

.btn-icon {
    background: none;
    border: none;
    padding: 0.5rem;
    border-radius: 8px;
    cursor: pointer;
    color: var(--dark-color);
    transition: var(--transition);
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-icon:hover {
    background: var(--light-color);
    color: var(--primary-color);
}

.widget-content {
    padding: 1.5rem;
}

/* Table Styles */
.table-container {
    background: var(--white);
    border-radius: 12px;
    overflow: hidden;
    box-shadow: var(--card-shadow);
}

.data-table {
    width: 100%;
    border-collapse: collapse;
}

.data-table th {
    background: rgba(0, 0, 0, 0.02);
    padding: 1rem 1.5rem;
    text-align: left;
    font-weight: 600;
    color: var(--dark-color);
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    white-space: nowrap;
}

.data-table td {
    padding: 1rem 1.5rem;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    color: var(--dark-color);
}

.data-table tr:hover {
    background: rgba(0, 0, 0, 0.02);
}

/* Status Badges */
.status-badge {
    padding: 0.25rem 0.75rem;
    border-radius: 999px;
    font-size: 0.75rem;
    font-weight: 500;
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
}

.status-badge.active {
    background: rgba(5, 150, 105, 0.1);
    color: var(--success-color);
}

.status-badge.pending {
    background: rgba(217, 119, 6, 0.1);
    color: var(--warning-color);
}

.status-badge.inactive {
    background: rgba(220, 38, 38, 0.1);
    color: var(--danger-color);
}

/* Chart Styles */
.chart-container {
    position: relative;
    height: 300px;
    width: 100%;
}

.chart-legend {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    margin-top: 1.5rem;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: var(--dark-color);
}

.legend-color {
    width: 12px;
    height: 12px;
    border-radius: 3px;
}

/* Activity List */
.activity-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.activity-item {
    display: flex;
    gap: 1rem;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.02);
    border-radius: 8px;
    transition: var(--transition);
}

.activity-item:hover {
    background: rgba(0, 0, 0, 0.04);
}

.activity-icon {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.25rem;
    color: var(--white);
}
        /* Activity Content Styles */
.activity-content {
    flex: 1;
}

.activity-title {
    font-weight: 500;
    color: var(--dark-color);
    margin-bottom: 0.25rem;
}

.activity-time {
    font-size: 0.875rem;
    color: var(--dark-color);
    opacity: 0.6;
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1100;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(4px);
}

.modal.active {
    display: flex;
}

.modal-content {
    background: var(--white);
    border-radius: 12px;
    width: 90%;
    max-width: 600px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    position: relative;
    animation: modalSlideIn 0.3s ease-out;
}

.modal-header {
    padding: 1.5rem;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(0, 0, 0, 0.02);
}

.modal-header h3 {
    margin: 0;
    font-size: 1.25rem;
    color: var(--dark-color);
}

.modal-body {
    padding: 1.5rem;
}

.modal-footer {
    padding: 1.5rem;
    border-top: 1px solid rgba(0, 0, 0, 0.05);
    display: flex;
    justify-content: flex-end;
    gap: 1rem;
    background: rgba(0, 0, 0, 0.02);
}

.close-modal {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--dark-color);
    opacity: 0.6;
    transition: var(--transition);
    padding: 0.5rem;
    border-radius: 8px;
}

.close-modal:hover {
    opacity: 1;
    background: rgba(0, 0, 0, 0.05);
}

/* Form Styles */
.form-group {
    margin-bottom: 1.5rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--dark-color);
}

.form-control {
    width: 100%;
    padding: 0.75rem 1rem;
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    font-size: 0.875rem;
    transition: var(--transition);
    background: var(--white);
}

.form-control:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

/* Loading States */
.loading-spinner {
    width: 24px;
    height: 24px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: var(--white);
    animation: spin 1s linear infinite;
}

.widget-loader {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
}

/* Dropdown Menu */
.dropdown {
    position: relative;
}

.dropdown-menu {
    position: absolute;
    top: 100%;
    right: 0;
    background: var(--white);
    border-radius: 8px;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    padding: 0.5rem 0;
    min-width: 200px;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transform: translateY(10px);
    transition: all 0.2s ease;
}

.dropdown.active .dropdown-menu {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}
        /* Dropdown Menu Items */
.dropdown-item {
    padding: 0.75rem 1rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    color: var(--dark-color);
    text-decoration: none;
    transition: var(--transition);
    cursor: pointer;
}

.dropdown-item:hover {
    background: rgba(0, 0, 0, 0.02);
    color: var(--primary-color);
}

.dropdown-divider {
    height: 1px;
    background: rgba(0, 0, 0, 0.05);
    margin: 0.5rem 0;
}

/* Animations */
@keyframes modalSlideIn {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

/* Responsive Design */
@media (min-width: 768px) {
    .user-info {
        display: flex;
        flex-direction: column;
    }

    .user-name {
        font-weight: 600;
        color: var(--dark-color);
        font-size: 0.875rem;
    }

    .user-role {
        font-size: 0.75rem;
        color: var(--dark-color);
        opacity: 0.6;
    }
}

@media (max-width: 1024px) {
    .stats-section {
        grid-template-columns: repeat(2, 1fr);
    }

    .dashboard-grid {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 768px) {
    .sidebar {
        transform: translateX(-100%);
        position: fixed;
        z-index: 1001;
    }

    .sidebar.active {
        transform: translateX(0);
    }

    .main-content {
        margin-left: 0;
    }

    .header {
        left: 0;
    }

    .menu-toggle {
        display: block;
    }

    .stats-section {
        grid-template-columns: 1fr;
    }

    .modal-content {
        width: 95%;
    }
}

/* Widget-specific Styles */
.revenue-chart {
    height: 300px;
    margin-top: 1rem;
}

.performance-metrics {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.metric-card {
    background: rgba(0, 0, 0, 0.02);
    padding: 1rem;
    border-radius: 8px;
    text-align: center;
}

.metric-value {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--dark-color);
    margin-bottom: 0.25rem;
}

.metric-label {
    font-size: 0.875rem;
    color: var(--dark-color);
    opacity: 0.6;
}

/* Utility Classes */
.text-primary { color: var(--primary-color); }
.text-success { color: var(--success-color); }
.text-warning { color: var(--warning-color); }
.text-danger { color: var(--danger-color); }
.text-info { color: var(--info-color); }

.bg-primary { background-color: var(--primary-color); }
.bg-success { background-color: var(--success-color); }
.bg-warning { background-color: var(--warning-color); }
.bg-danger { background-color: var(--danger-color); }
.bg-info { background-color: var(--info-color); }

.shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
.shadow { box-shadow: var(--card-shadow); }
.shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }

.rounded-sm { border-radius: 4px; }
.rounded { border-radius: 8px; }
.rounded-lg { border-radius: 12px; }
.rounded-full { border-radius: 9999px; }

.font-medium { font-weight: 500; }
.font-semibold { font-weight: 600; }
.font-bold { font-weight: 700; }

.text-sm { font-size: 0.875rem; }
.text-base { font-size: 1rem; }
.text-lg { font-size: 1.125rem; }
.text-xl { font-size: 1.25rem; }

.flex { display: flex; }
.items-center { align-items: center; }
.justify-between { justify-content: space-between; }
.gap-2 { gap: 0.5rem; }
.gap-4 { gap: 1rem; }

.w-full { width: 100%; }
.h-full { height: 100%; }

.p-4 { padding: 1rem; }
.p-6 { padding: 1.5rem; }
.py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
.px-4 { padding-left: 1rem; padding-right: 1rem; }

.m-4 { margin: 1rem; }
.mb-4 { margin-bottom: 1rem; }
.mt-4 { margin-top: 1rem; }
        /* Add only these new styles for the dropdown functionality */
.user-profile {
    position: relative;
    cursor: pointer;
}

.dropdown-menu {
    position: absolute;
    top: calc(100% + 8px);
    right: 0;
    background: var(--white);
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    width: 220px;
    padding: 8px 0;
    opacity: 0;
    visibility: hidden;
    transform: translateY(10px);
    transition: all 0.2s ease;
    z-index: 1000;
}

.dropdown-menu.show {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.dropdown-item {
    padding: 10px 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    color: var(--dark-color);
    text-decoration: none;
    transition: var(--transition);
    font-size: 0.875rem;
}

.dropdown-item:hover {
    background: rgba(0, 0, 0, 0.02);
    color: var(--primary-color);
}

.dropdown-item i {
    font-size: 1rem;
    opacity: 0.7;
    width: 16px;
}

.dropdown-divider {
    height: 1px;
    background: rgba(0, 0, 0, 0.05);
    margin: 8px 0;
}
      </style>
</head>
<body>
     <!-- Sidebar -->
   <!-- Sidebar -->
<div class="sidebar">
    <div class="sidebar-header">
        <img src="logo.png" alt="Logo">
        <h2>WorkWise Pro</h2>
    </div>
    <ul class="nav-menu">
        <li class="nav-item">
            <a href="#" class="nav-link active">
                <i class="fas fa-home"></i>
                <span>Overview</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-building"></i>
                <span>Client Companies</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-cogs"></i>
                <span>System Settings</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-tags"></i>
                <span>Pricing & Plans</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-shield-alt"></i>
                <span>Security Settings</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-puzzle-piece"></i>
                <span>Module Management</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-users-cog"></i>
                <span>User Management</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-chart-bar"></i>
                <span>Analytics & Reports</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-database"></i>
                <span>Backup & Restore</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-history"></i>
                <span>Audit Logs</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-plug"></i>
                <span>API Management</span>
            </a>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link">
                <i class="fas fa-life-ring"></i>
                <span>Support Center</span>
            </a>
        </li>
    </ul>
</div>

    
  <!-- Inside the main-content div, after the header -->
<!-- Main Content Area -->

    <!-- Header -->
   <!-- Header Section -->
<header class="header">
    <div class="header-left">
        <button id="sidebar-toggle" class="menu-toggle">
            <i class="fas fa-bars"></i>
        </button>
        <div class="breadcrumb">
            <h2>Dashboard</h2>
        </div>
    </div>
    
    <div class="header-right">
        <div class="header-actions">
            <div class="notification-bell">
                <i class="fas fa-bell"></i>
                <span class="badge">3</span>
            </div>
            <div class="user-profile" id="userProfileDropdown">
                <div class="profile-info">
                    <img src="https://ui-avatars.com/api/?name=Admin" alt="Profile" class="profile-img">
                    <div class="user-info">
                        <span class="user-name" id="userName">Loading...</span>
                        <span class="user-role" id="userRole">Loading...</span>
                    </div>
                    <i class="fas fa-chevron-down"></i>
                </div>
                <div class="dropdown-menu" id="userDropdownMenu">
                    <a href="#" class="dropdown-item">
                        <i class="fas fa-user"></i>
                        My Account
                    </a>
                    <div class="dropdown-divider"></div>
                    <a href="#" class="dropdown-item" id="signOutBtn">
                        <i class="fas fa-sign-out-alt"></i>
                        Sign Out
                    </a>
                </div>
            </div>
        </div>
  
</header>

    <!-- Dashboard Content -->
    <div class="dashboard-container">
        <!-- Quick Stats Section -->
        <div class="stats-section">
            <div class="stat-card">
                <div class="stat-icon" style="background: rgba(79, 70, 229, 0.1);">
                    <i class="fas fa-building" style="color: #4F46E5;"></i>
                </div>
                <div class="stat-info">
                    <h3>Total Companies</h3>
                    <div class="stat-value">247</div>
                    <div class="stat-change positive">
                        <i class="fas fa-arrow-up"></i>
                        <span>12% from last month</span>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon" style="background: rgba(16, 185, 129, 0.1);">
                    <i class="fas fa-users" style="color: #10B981;"></i>
                </div>
                <div class="stat-info">
                    <h3>Active Users</h3>
                    <div class="stat-value">15,482</div>
                    <div class="stat-change positive">
                        <i class="fas fa-arrow-up"></i>
                        <span>8.3% from last month</span>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon" style="background: rgba(245, 158, 11, 0.1);">
                    <i class="fas fa-chart-line" style="color: #F59E0B;"></i>
                </div>
                <div class="stat-info">
                    <h3>Monthly Revenue</h3>
                    <div class="stat-value">$1.2M</div>
                    <div class="stat-change positive">
                        <i class="fas fa-arrow-up"></i>
                        <span>24% from last month</span>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon" style="background: rgba(239, 68, 68, 0.1);">
                    <i class="fas fa-ticket-alt" style="color: #EF4444;"></i>
                </div>
                <div class="stat-info">
                    <h3>Support Tickets</h3>
                    <div class="stat-value">42</div>
                    <div class="stat-change negative">
                        <i class="fas fa-arrow-down"></i>
                        <span>5% from last month</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Customizable Dashboard Grid -->
        <div class="dashboard-grid" id="dashboardGrid">
            <!-- Recent Companies Section -->
            <div class="dashboard-widget" data-widget="recent-companies">
                <div class="widget-header">
                    <h3>Recent Companies</h3>
                    <div class="widget-actions">
                        <button class="btn-icon" onclick="refreshWidget('recent-companies')">
                            <i class="fas fa-sync"></i>
                        </button>
                        <button class="btn-icon" onclick="customizeWidget('recent-companies')">
                            <i class="fas fa-ellipsis-v"></i>
                        </button>
                    </div>
                </div>
                <div class="widget-content">
                    <div class="company-list">
                        <!-- Company items will be dynamically loaded -->
                    </div>
                </div>
            </div>

            <!-- System Health Section -->
            <div class="dashboard-widget" data-widget="system-health">
                <div class="widget-header">
                    <h3>System Health</h3>
                    <div class="widget-actions">
                        <button class="btn-icon" onclick="refreshWidget('system-health')">
                            <i class="fas fa-sync"></i>
                        </button>
                        <button class="btn-icon" onclick="customizeWidget('system-health')">
                            <i class="fas fa-ellipsis-v"></i>
                        </button>
                    </div>
                </div>
                <div class="widget-content">
                    <!-- System health metrics will be dynamically loaded -->
                </div>
            </div>

            <!-- Revenue Analytics Section -->
            <div class="dashboard-widget" data-widget="revenue-analytics">
                <div class="widget-header">
                    <h3>Revenue Analytics</h3>
                    <div class="widget-actions">
                        <button class="btn-icon" onclick="refreshWidget('revenue-analytics')">
                            <i class="fas fa-sync"></i>
                        </button>
                        <button class="btn-icon" onclick="customizeWidget('revenue-analytics')">
                            <i class="fas fa-ellipsis-v"></i>
                        </button>
                    </div>
                </div>
                <div class="widget-content">
                    <canvas id="revenueChart"></canvas>
                </div>
            </div>

            <!-- Recent Activities Section -->
            <div class="dashboard-widget" data-widget="recent-activities">
                <div class="widget-header">
                    <h3>Recent Activities</h3>
                    <div class="widget-actions">
                        <button class="btn-icon" onclick="refreshWidget('recent-activities')">
                            <i class="fas fa-sync"></i>
                        </button>
                        <button class="btn-icon" onclick="customizeWidget('recent-activities')">
                            <i class="fas fa-ellipsis-v"></i>
                        </button>
                    </div>
                </div>
                <div class="widget-content">
                    <!-- Activities will be dynamically loaded -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Dashboard Customization Modal -->
<div class="modal" id="customizeDashboardModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Customize Dashboard</h2>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <div class="available-widgets">
                <!-- Widget options will be dynamically loaded -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeCustomizeModal()">Cancel</button>
            <button class="btn btn-primary" onclick="saveDashboardLayout()">Save Changes</button>
        </div>
    </div>
</div>
  
</body>
  

 <script>
    // User Profile Dropdown Functionality
document.addEventListener('DOMContentLoaded', function() {
    // Check authentication
    const token = localStorage.getItem('token');
    if (!token) {
        window.location.href = 'login.html';
        return;
    }

    // Initialize user info
    const userEmail = localStorage.getItem('userEmail');
    const userRole = localStorage.getItem('userRole');
    if (userEmail && userRole) {
        document.getElementById('userName').textContent = userEmail;
        document.getElementById('userRole').textContent = 
            userRole.charAt(0).toUpperCase() + userRole.slice(1);
    }

    // Dropdown functionality
    const userProfile = document.getElementById('userProfileDropdown');
    const dropdownMenu = document.getElementById('userDropdownMenu');
    const signOutBtn = document.getElementById('signOutBtn');

    // Toggle dropdown
    userProfile.addEventListener('click', function(e) {
        e.stopPropagation();
        dropdownMenu.classList.toggle('show');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', function() {
        dropdownMenu.classList.remove('show');
    });

    // Prevent dropdown from closing when clicking inside
    dropdownMenu.addEventListener('click', function(e) {
        e.stopPropagation();
    });

    // Sign out functionality
    signOutBtn.addEventListener('click', function(e) {
        e.preventDefault();
        localStorage.clear();
        window.location.href = 'login.html';
    });
});
     // Dashboard Management System
class DashboardManager {
    constructor() {
        this.widgets = new Map();
        this.layout = [];
        this.availableWidgets = {
            'recent-companies': {
                title: 'Recent Companies',
                icon: 'building',
                refreshInterval: 300000, // 5 minutes
                minHeight: 400
            },
            'system-health': {
                title: 'System Health',
                icon: 'heartbeat',
                refreshInterval: 60000, // 1 minute
                minHeight: 300
            },
            'revenue-analytics': {
                title: 'Revenue Analytics',
                icon: 'chart-line',
                refreshInterval: 900000, // 15 minutes
                minHeight: 400
            },
            'active-users': {
                title: 'Active Users',
                icon: 'users',
                refreshInterval: 60000,
                minHeight: 300
            },
            'recent-activities': {
                title: 'Recent Activities',
                icon: 'history',
                refreshInterval: 120000, // 2 minutes
                minHeight: 400
            },
            'support-tickets': {
                title: 'Support Tickets',
                icon: 'ticket-alt',
                refreshInterval: 300000,
                minHeight: 350
            }
        };
        this.initializeDashboard();
    }

    async initializeDashboard() {
        this.loadSavedLayout();
        this.initializeEventListeners();
        await this.renderDashboard();
        this.setupRefreshIntervals();
    }

    // Load saved dashboard layout from localStorage
    loadSavedLayout() {
        const savedLayout = localStorage.getItem('dashboardLayout');
        this.layout = savedLayout ? JSON.parse(savedLayout) : this.getDefaultLayout();
    }

    // Default dashboard layout
    getDefaultLayout() {
        return [
            'recent-companies',
            'system-health',
            'revenue-analytics',
            'recent-activities'
        ];
    }

    // Initialize event listeners
    initializeEventListeners() {
        // Customize dashboard button
        document.getElementById('customizeBtn').addEventListener('click', 
            () => this.openCustomizeModal());

        // Widget drag and drop
        const dashboardGrid = document.getElementById('dashboardGrid');
        new Sortable(dashboardGrid, {
            animation: 150,
            handle: '.widget-header',
            onEnd: () => this.saveCurrentLayout()
        });
    }

    // Render dashboard
    async renderDashboard() {
        const dashboardGrid = document.getElementById('dashboardGrid');
        dashboardGrid.innerHTML = '';

        for (const widgetId of this.layout) {
            if (this.availableWidgets[widgetId]) {
                const widget = await this.createWidget(widgetId);
                dashboardGrid.appendChild(widget);
            }
        }
    }

    // Create widget element
    async createWidget(widgetId) {
        const widgetConfig = this.availableWidgets[widgetId];
        const widget = document.createElement('div');
        widget.className = 'dashboard-widget';
        widget.dataset.widget = widgetId;
        widget.innerHTML = `
            <div class="widget-header">
                <h3>
                    <i class="fas fa-${widgetConfig.icon}"></i>
                    ${widgetConfig.title}
                </h3>
                <div class="widget-actions">
                    <button class="btn-icon refresh-widget" title="Refresh">
                        <i class="fas fa-sync"></i>
                    </button>
                    <button class="btn-icon customize-widget" title="Customize">
                        <i class="fas fa-cog"></i>
                    </button>
                    <button class="btn-icon remove-widget" title="Remove">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <div class="widget-content">
                <div class="widget-loader">
                    <i class="fas fa-spinner fa-spin"></i>
                </div>
            </div>
        `;

        // Add event listeners
        widget.querySelector('.refresh-widget').addEventListener('click', 
            () => this.refreshWidget(widgetId));
        widget.querySelector('.customize-widget').addEventListener('click', 
            () => this.customizeWidget(widgetId));
        widget.querySelector('.remove-widget').addEventListener('click', 
            () => this.removeWidget(widgetId));

        // Load widget content
        await this.loadWidgetContent(widget, widgetId);
        return widget;
    }

    // Load widget content
    async loadWidgetContent(widget, widgetId) {
        const contentDiv = widget.querySelector('.widget-content');
        try {
            const data = await this.fetchWidgetData(widgetId);
            contentDiv.innerHTML = await this.renderWidgetContent(widgetId, data);
        } catch (error) {
            contentDiv.innerHTML = `
                <div class="widget-error">
                    <i class="fas fa-exclamation-circle"></i>
                    <p>Error loading widget content</p>
                </div>
            `;
        }
    }

    // Fetch widget data
    async fetchWidgetData(widgetId) {
        // Implement API calls based on widget type
        switch (widgetId) {
            case 'recent-companies':
                return await this.fetchRecentCompanies();
            case 'system-health':
                return await this.fetchSystemHealth();
            case 'revenue-analytics':
                return await this.fetchRevenueAnalytics();
            // Add more cases for other widgets
        }
    }

    // Render widget content based on type
    async renderWidgetContent(widgetId, data) {
        switch (widgetId) {
            case 'recent-companies':
                return this.renderRecentCompanies(data);
            case 'system-health':
                return this.renderSystemHealth(data);
            case 'revenue-analytics':
                return this.renderRevenueAnalytics(data);
            // Add more cases for other widgets
        }
    }

    // Customize Modal
    openCustomizeModal() {
        const modal = document.createElement('div');
        modal.className = 'modal active';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Customize Dashboard</h2>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="available-widgets">
                        ${this.renderAvailableWidgets()}
                    </div>
                    <div class="layout-preview">
                        ${this.renderLayoutPreview()}
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-action="cancel">Cancel</button>
                    <button class="btn btn-primary" data-action="save">Save Changes</button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
        this.initializeModalEventListeners(modal);
    }

    // Render available widgets
    renderAvailableWidgets() {
        return Object.entries(this.availableWidgets)
            .map(([id, config]) => `
                <div class="widget-option" data-widget="${id}">
                    <i class="fas fa-${config.icon}"></i>
                    <span>${config.title}</span>
                    <button class="btn-icon add-widget">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
            `).join('');
    }

    // Save dashboard layout
    saveCurrentLayout() {
        const widgets = Array.from(document.querySelectorAll('.dashboard-widget'))
            .map(widget => widget.dataset.widget);
        this.layout = widgets;
        localStorage.setItem('dashboardLayout', JSON.stringify(widgets));
    }

    // Refresh intervals
    setupRefreshIntervals() {
        for (const [widgetId, config] of Object.entries(this.availableWidgets)) {
            if (this.layout.includes(widgetId)) {
                setInterval(() => this.refreshWidget(widgetId), config.refreshInterval);
            }
        }
    }

    // Refresh widget
    async refreshWidget(widgetId) {
        const widget = document.querySelector(`[data-widget="${widgetId}"]`);
        if (widget) {
            const refreshButton = widget.querySelector('.refresh-widget i');
            refreshButton.classList.add('fa-spin');
            await this.loadWidgetContent(widget, widgetId);
            refreshButton.classList.remove('fa-spin');
        }
    }

    // Remove widget
    async removeWidget(widgetId) {
        const widget = document.querySelector(`[data-widget="${widgetId}"]`);
        if (widget) {
            widget.remove();
            this.saveCurrentLayout();
        }
    }
}

// Initialize Dashboard
const dashboardManager = new DashboardManager();

// Export for use in other modules
export { DashboardManager };

     // Widget Implementations
class DashboardWidgets {
    // Recent Companies Widget
    static async renderRecentCompanies(data) {
        return `
            <div class="companies-list">
                ${data.companies.map(company => `
                    <div class="company-item">
                        <div class="company-info">
                            <div class="company-logo" style="background-color: ${this.getRandomColor()}">
                                ${this.getCompanyInitials(company.name)}
                            </div>
                            <div class="company-details">
                                <h4>${company.name}</h4>
                                <span>${company.industry}</span>
                            </div>
                        </div>
                        <div class="company-stats">
                            <div class="stat">
                                <span class="stat-label">Employees</span>
                                <span class="stat-value">${company.employeeCount}</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Status</span>
                                <span class="status-badge ${company.status.toLowerCase()}">
                                    ${company.status}
                                </span>
                            </div>
                        </div>
                        <div class="company-actions">
                            <button class="btn-icon" onclick="viewCompany('${company.id}')">
                                <i class="fas fa-eye"></i>
                            </button>
                            <button class="btn-icon" onclick="editCompany('${company.id}')">
                                <i class="fas fa-edit"></i>
                            </button>
                        </div>
                    </div>
                `).join('')}
            </div>
            <div class="widget-footer">
                <button class="btn btn-link" onclick="viewAllCompanies()">
                    View All Companies <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        `;
    }

    // System Health Widget
    static async renderSystemHealth(data) {
        const getHealthStatus = (value, threshold) => {
            if (value >= threshold.good) return 'good';
            if (value >= threshold.warning) return 'warning';
            return 'critical';
        };

        return `
            <div class="system-health-metrics">
                <div class="health-metric">
                    <div class="metric-header">
                        <h4>System Performance</h4>
                        <span class="health-indicator ${getHealthStatus(data.performance, {good: 90, warning: 70})}">
                            ${data.performance}%
                        </span>
                    </div>
                    <div class="metric-chart">
                        <canvas id="performanceChart"></canvas>
                    </div>
                </div>

                <div class="metrics-grid">
                    <div class="metric-card ${getHealthStatus(data.cpu.usage, {good: 70, warning: 85})}">
                        <div class="metric-icon">
                            <i class="fas fa-microchip"></i>
                        </div>
                        <div class="metric-info">
                            <h5>CPU Usage</h5>
                            <span class="metric-value">${data.cpu.usage}%</span>
                        </div>
                    </div>

                    <div class="metric-card ${getHealthStatus(data.memory.usage, {good: 70, warning: 85})}">
                        <div class="metric-icon">
                            <i class="fas fa-memory"></i>
                        </div>
                        <div class="metric-info">
                            <h5>Memory Usage</h5>
                            <span class="metric-value">${data.memory.usage}%</span>
                        </div>
                    </div>

                    <div class="metric-card ${getHealthStatus(data.storage.usage, {good: 70, warning: 85})}">
                        <div class="metric-icon">
                            <i class="fas fa-hdd"></i>
                        </div>
                        <div class="metric-info">
                            <h5>Storage Usage</h5>
                            <span class="metric-value">${data.storage.usage}%</span>
                        </div>
                    </div>

                    <div class="metric-card ${data.network.status}">
                        <div class="metric-icon">
                            <i class="fas fa-network-wired"></i>
                        </div>
                        <div class="metric-info">
                            <h5>Network Status</h5>
                            <span class="metric-value">${data.network.latency}ms</span>
                        </div>
                    </div>
                </div>

                <div class="active-issues">
                    <h4>Active Issues (${data.issues.length})</h4>
                    <div class="issues-list">
                        ${data.issues.map(issue => `
                            <div class="issue-item ${issue.severity}">
                                <div class="issue-icon">
                                    <i class="fas fa-exclamation-${issue.severity === 'critical' ? 'circle' : 'triangle'}"></i>
                                </div>
                                <div class="issue-details">
                                    <h5>${issue.title}</h5>
                                    <span>${issue.description}</span>
                                </div>
                                <div class="issue-time">
                                    ${this.formatTimeAgo(issue.timestamp)}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
    }

    // Revenue Analytics Widget
    static async renderRevenueAnalytics(data) {
        return `
            <div class="revenue-analytics">
                <div class="revenue-summary">
                    <div class="summary-card">
                        <h4>Total Revenue</h4>
                        <div class="amount">$${this.formatNumber(data.totalRevenue)}</div>
                        <div class="trend ${data.revenueGrowth >= 0 ? 'positive' : 'negative'}">
                            <i class="fas fa-arrow-${data.revenueGrowth >= 0 ? 'up' : 'down'}"></i>
                            ${Math.abs(data.revenueGrowth)}%
                        </div>
                    </div>
                    <div class="summary-card">
                        <h4>Active Subscriptions</h4>
                        <div class="amount">${this.formatNumber(data.activeSubscriptions)}</div>
                        <div class="trend ${data.subscriptionGrowth >= 0 ? 'positive' : 'negative'}">
                            <i class="fas fa-arrow-${data.subscriptionGrowth >= 0 ? 'up' : 'down'}"></i>
                            ${Math.abs(data.subscriptionGrowth)}%
                        </div>
                    </div>
                </div>

                <div class="revenue-chart">
                    <canvas id="revenueChart"></canvas>
                </div>

                <div class="revenue-breakdown">
                    <h4>Revenue by Plan</h4>
                    <div class="plan-breakdown">
                        ${data.revenuePlans.map(plan => `
                            <div class="plan-item">
                                <div class="plan-info">
                                    <h5>${plan.name}</h5>
                                    <span>${plan.subscribers} subscribers</span>
                                </div>
                                <div class="plan-revenue">
                                    <div class="amount">$${this.formatNumber(plan.revenue)}</div>
                                    <div class="percentage">${plan.percentage}%</div>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress" style="width: ${plan.percentage}%; background-color: ${plan.color}"></div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
    }

    // Recent Activities Widget
    static async renderRecentActivities(data) {
        return `
            <div class="activities-list">
                ${data.activities.map(activity => `
                    <div class="activity-item">
                        <div class="activity-icon" style="background-color: ${this.getActivityColor(activity.type)}">
                            <i class="fas ${this.getActivityIcon(activity.type)}"></i>
                        </div>
                        <div class="activity-details">
                            <div class="activity-header">
                                <h5>${activity.title}</h5>
                                <span class="activity-time">${this.formatTimeAgo(activity.timestamp)}</span>
                            </div>
                            <p>${activity.description}</p>
                            ${activity.metadata ? `
                                <div class="activity-metadata">
                                    ${this.renderActivityMetadata(activity.metadata)}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `).join('')}
            </div>
            <div class="widget-footer">
                <button class="btn btn-link" onclick="viewAllActivities()">
                    View All Activities <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        `;
    }

    // Support Tickets Widget
    static async renderSupportTickets(data) {
        return `
            <div class="support-tickets">
                <div class="tickets-summary">
                    <div class="summary-card">
                        <h4>Open Tickets</h4>
                        <div class="amount">${data.openTickets}</div>
                        <div class="trend">
                            ${this.renderTicketTrend(data.ticketTrend)}
                        </div>
                    </div>
                    <div class="tickets-metrics">
                        <div class="metric">
                            <span class="label">Average Response Time</span>
                            <span class="value">${data.avgResponseTime}</span>
                        </div>
                        <div class="metric">
                            <span class="label">Resolution Rate</span>
                            <span class="value">${data.resolutionRate}%</span>
                        </div>
                    </div>
                </div>

                <div class="tickets-list">
                    ${data.recentTickets.map(ticket => `
                        <div class="ticket-item ${ticket.priority}">
                            <div class="ticket-header">
                                <div class="ticket-id">#${ticket.id}</div>
                                <div class="ticket-priority">${ticket.priority}</div>
                            </div>
                            <div class="ticket-content">
                                <h5>${ticket.subject}</h5>
                                <p>${ticket.description}</p>
                            </div>
                            <div class="ticket-footer">
                                <div class="ticket-company">
                                    <img src="${ticket.company.logo}" alt="${ticket.company.name}">
                                    <span>${ticket.company.name}</span>
                                </div>
                                <div class="ticket-time">
                                    ${this.formatTimeAgo(ticket.createdAt)}
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // Utility Methods
    static formatNumber(number) {
        return new Intl.NumberFormat().format(number);
    }

    static formatTimeAgo(timestamp) {
        const now = new Date();
        const time = new Date(timestamp);
        const diff = Math.floor((now - time) / 1000);

        if (diff < 60) return 'just now';
        if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
        if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
        return `${Math.floor(diff / 86400)}d ago`;
    }

    static getRandomColor() {
        const colors = ['#4F46E5', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    static getCompanyInitials(name) {
        return name
            .split(' ')
            .map(word => word[0])
            .join('')
            .substring(0, 2)
            .toUpperCase();
    }

    static getActivityIcon(type) {
        const icons = {
            'user': 'fa-user',
            'company': 'fa-building',
            'subscription': 'fa-credit-card',
            'system': 'fa-cog',
            'security': 'fa-shield-alt'
        };
        return icons[type] || 'fa-info-circle';
    }

    static getActivityColor(type) {
        const colors = {
            'user': '#4F46E5',
            'company': '#10B981',
            'subscription': '#F59E0B',
            'system': '#6B7280',
            'security': '#EF4444'
        };
        return colors[type] || '#6B7280';
    }

    static renderActivityMetadata(metadata) {
        return Object.entries(metadata)
            .map(([key, value]) => `
                <div class="metadata-item">
                    <span class="key">${key}:</span>
                    <span class="value">${value}</span>
                </div>
            `).join('');
    }

    static renderTicketTrend(trend) {
        const isPositive = trend >= 0;
        return `
            <div class="trend ${isPositive ? 'positive' : 'negative'}">
                <i class="fas fa-arrow-${isPositive ? 'up' : 'down'}"></i>
                ${Math.abs(trend)}%
            </div>
        `;
    }
}

// Export for use in dashboard manager
export { DashboardWidgets };

// API Service for Widget Data
class WidgetDataService {
    constructor() {
        this.baseUrl = 'https://your-api-endpoint.com/api';
        this.token = localStorage.getItem('token');
    }

    // Common headers for API requests
    get headers() {
        return {
            'Authorization': `Bearer ${this.token}`,
            'Content-Type': 'application/json'
        };
    }

    // Generic API call method
    async fetchData(endpoint, options = {}) {
        try {
            const response = await fetch(`${this.baseUrl}${endpoint}`, {
                ...options,
                headers: this.headers
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('API Request Failed:', error);
            throw error;
        }
    }

    // Recent Companies Data
    async fetchRecentCompanies() {
        return this.fetchData('/companies/recent', {
            method: 'GET',
            params: {
                limit: 5,
                sort: 'createdAt',
                order: 'desc'
            }
        });
    }

    // System Health Data
    async fetchSystemHealth() {
        const [performance, resources, issues] = await Promise.all([
            this.fetchData('/system/performance'),
            this.fetchData('/system/resources'),
            this.fetchData('/system/issues')
        ]);

        return {
            performance,
            resources,
            issues
        };
    }

    // Revenue Analytics Data
    async fetchRevenueAnalytics(timeframe = 'month') {
        return this.fetchData('/analytics/revenue', {
            method: 'GET',
            params: {
                timeframe,
                includeBreakdown: true
            }
        });
    }

    // Recent Activities Data
    async fetchRecentActivities() {
        return this.fetchData('/activities/recent', {
            method: 'GET',
            params: {
                limit: 10,
                includeMetadata: true
            }
        });
    }

    // Support Tickets Data
    async fetchSupportTickets() {
        return this.fetchData('/support/tickets', {
            method: 'GET',
            params: {
                status: 'open',
                sort: 'priority'
            }
        });
    }
}

// Widget Data Handlers
class WidgetDataHandler {
    constructor() {
        this.dataService = new WidgetDataService();
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
    }

    // Cache management
    isCacheValid(key) {
        const cached = this.cache.get(key);
        if (!cached) return false;
        return (Date.now() - cached.timestamp) < this.cacheTimeout;
    }

    setCacheData(key, data) {
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }

    // Recent Companies Handler
    async getRecentCompanies() {
        const cacheKey = 'recent-companies';
        
        if (this.isCacheValid(cacheKey)) {
            return this.cache.get(cacheKey).data;
        }

        try {
            const data = await this.dataService.fetchRecentCompanies();
            this.setCacheData(cacheKey, data);
            return data;
        } catch (error) {
            console.error('Failed to fetch recent companies:', error);
            throw error;
        }
    }

    // System Health Handler
    async getSystemHealth() {
        const cacheKey = 'system-health';
        
        // Short cache timeout for system health
        const healthCacheTimeout = 60 * 1000; // 1 minute

        if (this.cache.has(cacheKey) && 
            (Date.now() - this.cache.get(cacheKey).timestamp) < healthCacheTimeout) {
            return this.cache.get(cacheKey).data;
        }

        try {
            const data = await this.dataService.fetchSystemHealth();
            this.setCacheData(cacheKey, data);
            return data;
        } catch (error) {
            console.error('Failed to fetch system health:', error);
            throw error;
        }
    }

    // Revenue Analytics Handler
    async getRevenueAnalytics(timeframe) {
        const cacheKey = `revenue-analytics-${timeframe}`;
        
        if (this.isCacheValid(cacheKey)) {
            return this.cache.get(cacheKey).data;
        }

        try {
            const data = await this.dataService.fetchRevenueAnalytics(timeframe);
            this.setCacheData(cacheKey, data);
            return data;
        } catch (error) {
            console.error('Failed to fetch revenue analytics:', error);
            throw error;
        }
    }

    // Recent Activities Handler
    async getRecentActivities() {
        const cacheKey = 'recent-activities';
        
        if (this.isCacheValid(cacheKey)) {
            return this.cache.get(cacheKey).data;
        }

        try {
            const data = await this.dataService.fetchRecentActivities();
            this.setCacheData(cacheKey, data);
            return data;
        } catch (error) {
            console.error('Failed to fetch recent activities:', error);
            throw error;
        }
    }

    // Support Tickets Handler
    async getSupportTickets() {
        const cacheKey = 'support-tickets';
        
        if (this.isCacheValid(cacheKey)) {
            return this.cache.get(cacheKey).data;
        }

        try {
            const data = await this.dataService.fetchSupportTickets();
            this.setCacheData(cacheKey, data);
            return data;
        } catch (error) {
            console.error('Failed to fetch support tickets:', error);
            throw error;
        }
    }
}

// Real-time Updates Handler
class RealTimeUpdatesHandler {
    constructor() {
        this.socket = null;
        this.subscribers = new Map();
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 5000; // 5 seconds
    }

    // Initialize WebSocket connection
    initializeSocket() {
        this.socket = new WebSocket('wss://your-websocket-endpoint.com');

        this.socket.onopen = () => {
            console.log('WebSocket connected');
            this.reconnectAttempts = 0;
        };

        this.socket.onmessage = (event) => {
            const update = JSON.parse(event.data);
            this.handleUpdate(update);
        };

        this.socket.onclose = () => {
            console.log('WebSocket disconnected');
            this.attemptReconnect();
        };

        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
    }

    // Handle reconnection
    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            setTimeout(() => {
                this.reconnectAttempts++;
                this.initializeSocket();
            }, this.reconnectDelay);
        }
    }

    // Subscribe to updates
    subscribe(widgetId, callback) {
        if (!this.subscribers.has(widgetId)) {
            this.subscribers.set(widgetId, new Set());
        }
        this.subscribers.get(widgetId).add(callback);
    }

    // Unsubscribe from updates
    unsubscribe(widgetId, callback) {
        if (this.subscribers.has(widgetId)) {
            this.subscribers.get(widgetId).delete(callback);
        }
    }

    // Handle incoming updates
    handleUpdate(update) {
        const { type, data } = update;
        
        if (this.subscribers.has(type)) {
            this.subscribers.get(type).forEach(callback => {
                callback(data);
            });
        }
    }

    // Send message to server
    sendMessage(type, data) {
        if (this.socket && this.socket.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify({ type, data }));
        }
    }
}

// Widget Data Manager
class WidgetDataManager {
    constructor() {
        this.dataHandler = new WidgetDataHandler();
        this.realTimeHandler = new RealTimeUpdatesHandler();
        this.initializeRealTimeUpdates();
    }

    // Initialize real-time updates
    initializeRealTimeUpdates() {
        this.realTimeHandler.initializeSocket();
    }

    // Get widget data
    async getWidgetData(widgetId, params = {}) {
        switch (widgetId) {
            case 'recent-companies':
                return this.dataHandler.getRecentCompanies();
            case 'system-health':
                return this.dataHandler.getSystemHealth();
            case 'revenue-analytics':
                return this.dataHandler.getRevenueAnalytics(params.timeframe);
            case 'recent-activities':
                return this.dataHandler.getRecentActivities();
            case 'support-tickets':
                return this.dataHandler.getSupportTickets();
            default:
                throw new Error(`Unknown widget type: ${widgetId}`);
        }
    }

    // Subscribe to real-time updates
    subscribeToUpdates(widgetId, callback) {
        this.realTimeHandler.subscribe(widgetId, callback);
    }

    // Unsubscribe from real-time updates
    unsubscribeFromUpdates(widgetId, callback) {
        this.realTimeHandler.unsubscribe(widgetId, callback);
    }
}

// Export the Widget Data Manager
export const widgetDataManager = new WidgetDataManager();     

 // Chart Configurations and Implementations
class ChartManager {
    constructor() {
        this.charts = new Map();
        this.defaultOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
                duration: 1000,
                easing: 'easeInOutQuart'
            }
        };
    }

    // Revenue Chart Configuration
    createRevenueChart(containerId, data) {
        const ctx = document.getElementById(containerId).getContext('2d');
        const gradientFill = ctx.createLinearGradient(0, 0, 0, 400);
        gradientFill.addColorStop(0, 'rgba(79, 70, 229, 0.2)');
        gradientFill.addColorStop(1, 'rgba(79, 70, 229, 0)');

        const config = {
            type: 'line',
            data: {
                labels: data.labels,
                datasets: [{
                    label: 'Revenue',
                    data: data.values,
                    borderColor: '#4F46E5',
                    borderWidth: 2,
                    backgroundColor: gradientFill,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 4,
                    pointBackgroundColor: '#4F46E5',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointHoverRadius: 6,
                    pointHoverBackgroundColor: '#4F46E5',
                    pointHoverBorderColor: '#fff',
                    pointHoverBorderWidth: 2
                }]
            },
            options: {
                ...this.defaultOptions,
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: 12
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        ticks: {
                            callback: (value) => `$${this.formatNumber(value)}`,
                            font: {
                                size: 12
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleFont: {
                            size: 13
                        },
                        bodyFont: {
                            size: 12
                        },
                        padding: 12,
                        callbacks: {
                            label: (context) => `Revenue: $${this.formatNumber(context.raw)}`
                        }
                    }
                }
            }
        };

        return new Chart(ctx, config);
    }

    // System Health Chart Configuration
    createSystemHealthChart(containerId, data) {
        const ctx = document.getElementById(containerId).getContext('2d');

        const config = {
            type: 'doughnut',
            data: {
                labels: ['CPU', 'Memory', 'Storage', 'Network'],
                datasets: [{
                    data: [
                        data.cpu.usage,
                        data.memory.usage,
                        data.storage.usage,
                        data.network.usage
                    ],
                    backgroundColor: [
                        '#4F46E5',
                        '#10B981',
                        '#F59E0B',
                        '#3B82F6'
                    ],
                    borderWidth: 0,
                    borderRadius: 4
                }]
            },
            options: {
                ...this.defaultOptions,
                cutout: '70%',
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            padding: 20,
                            usePointStyle: true,
                            pointStyle: 'circle'
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => `${context.label}: ${context.raw}%`
                        }
                    }
                }
            }
        };

        return new Chart(ctx, config);
    }

    // User Activity Chart Configuration
    createActivityChart(containerId, data) {
        const ctx = document.getElementById(containerId).getContext('2d');

        const config = {
            type: 'bar',
            data: {
                labels: data.labels,
                datasets: [{
                    label: 'Active Users',
                    data: data.values,
                    backgroundColor: '#4F46E5',
                    borderRadius: 4,
                    barThickness: 12
                }]
            },
            options: {
                ...this.defaultOptions,
                scales: {
                    x: {
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        };

        return new Chart(ctx, config);
    }

    // Subscription Trend Chart Configuration
    createSubscriptionTrendChart(containerId, data) {
        const ctx = document.getElementById(containerId).getContext('2d');

        const config = {
            type: 'line',
            data: {
                labels: data.labels,
                datasets: data.plans.map((plan, index) => ({
                    label: plan.name,
                    data: plan.values,
                    borderColor: this.getChartColor(index),
                    backgroundColor: this.getChartColor(index, 0.1),
                    fill: true,
                    tension: 0.4,
                    pointRadius: 3,
                    pointBackgroundColor: this.getChartColor(index)
                }))
            },
            options: {
                ...this.defaultOptions,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        ticks: {
                            callback: (value) => this.formatNumber(value)
                        }
                    }
                }
            }
        };

        return new Chart(ctx, config);
    }

    // Performance Metrics Chart Configuration
    createPerformanceChart(containerId, data) {
        const ctx = document.getElementById(containerId).getContext('2d');

        const config = {
            type: 'radar',
            data: {
                labels: ['Response Time', 'Throughput', 'Error Rate', 'CPU Usage', 'Memory Usage'],
                datasets: [{
                    label: 'Current',
                    data: data.current,
                    borderColor: '#4F46E5',
                    backgroundColor: 'rgba(79, 70, 229, 0.2)',
                    pointBackgroundColor: '#4F46E5',
                    pointBorderColor: '#fff'
                }, {
                    label: 'Previous',
                    data: data.previous,
                    borderColor: '#10B981',
                    backgroundColor: 'rgba(16, 185, 129, 0.2)',
                    pointBackgroundColor: '#10B981',
                    pointBorderColor: '#fff'
                }]
            },
            options: {
                ...this.defaultOptions,
                scales: {
                    r: {
                        beginAtZero: true,
                        ticks: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'bottom'
                    }
                }
            }
        };

        return new Chart(ctx, config);
    }

    // Utility Methods
    formatNumber(number) {
        return new Intl.NumberFormat().format(number);
    }

    getChartColor(index, alpha = 1) {
        const colors = [
            `rgba(79, 70, 229, ${alpha})`,    // Primary
            `rgba(16, 185, 129, ${alpha})`,   // Success
            `rgba(245, 158, 11, ${alpha})`,   // Warning
            `rgba(59, 130, 246, ${alpha})`,   // Info
            `rgba(239, 68, 68, ${alpha})`     // Danger
        ];
        return colors[index % colors.length];
    }

    // Chart Update Methods
    updateChart(chartId, newData) {
        const chart = this.charts.get(chartId);
        if (chart) {
            chart.data = newData;
            chart.update('active');
        }
    }

    // Chart Destruction
    destroyChart(chartId) {
        const chart = this.charts.get(chartId);
        if (chart) {
            chart.destroy();
            this.charts.delete(chartId);
        }
    }

    // Chart Resize Handler
    handleResize() {
        this.charts.forEach(chart => {
            chart.resize();
        });
    }
}

// Chart Animation Utilities
const chartAnimations = {
    easeInOutQuart: (t) => {
        return t < 0.5 
            ? 8 * t * t * t * t 
            : 1 - 8 * (--t) * t * t * t;
    },
    
    bounceIn: (t) => {
        return 1 - Math.pow(1 - t, 3);
    }
};

// Initialize Chart Manager
const chartManager = new ChartManager();

// Add window resize listener
window.addEventListener('resize', () => {
    chartManager.handleResize();
});

// Export Chart Manager
export { chartManager };    

     // Advanced Chart Types and Customizations
class AdvancedChartManager extends ChartManager {
    constructor() {
        super();
        this.customThemes = new Map();
        this.initializeCustomThemes();
    }

    // Custom Themes Configuration
    initializeCustomThemes() {
        this.customThemes.set('light', {
            backgroundColor: '#ffffff',
            textColor: '#1F2937',
            gridColor: 'rgba(0, 0, 0, 0.05)',
            tooltipBackground: 'rgba(0, 0, 0, 0.8)',
            colors: [
                '#4F46E5', '#10B981', '#F59E0B', 
                '#3B82F6', '#EF4444', '#8B5CF6'
            ]
        });

        this.customThemes.set('dark', {
            backgroundColor: '#1F2937',
            textColor: '#F9FAFB',
            gridColor: 'rgba(255, 255, 255, 0.1)',
            tooltipBackground: 'rgba(0, 0, 0, 0.9)',
            colors: [
                '#818CF8', '#34D399', '#FBBF24', 
                '#60A5FA', '#F87171', '#A78BFA'
            ]
        });
    }

    // Stacked Area Chart
    createStackedAreaChart(containerId, data, options = {}) {
        const ctx = document.getElementById(containerId).getContext('2d');
        const theme = this.customThemes.get(options.theme || 'light');

        const config = {
            type: 'line',
            data: {
                labels: data.labels,
                datasets: data.datasets.map((dataset, index) => ({
                    label: dataset.label,
                    data: dataset.data,
                    backgroundColor: theme.colors[index],
                    borderColor: theme.colors[index],
                    fill: true,
                    tension: 0.4
                }))
            },
            options: {
                ...this.defaultOptions,
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: theme.textColor
                        }
                    },
                    y: {
                        stacked: true,
                        grid: {
                            color: theme.gridColor
                        },
                        ticks: {
                            color: theme.textColor
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        backgroundColor: theme.tooltipBackground,
                        mode: 'index'
                    }
                }
            }
        };

        return new Chart(ctx, config);
    }

    // Bubble Chart for Resource Usage
    createResourceBubbleChart(containerId, data, options = {}) {
        const ctx = document.getElementById(containerId).getContext('2d');
        const theme = this.customThemes.get(options.theme || 'light');

        const config = {
            type: 'bubble',
            data: {
                datasets: data.map((dataset, index) => ({
                    label: dataset.label,
                    data: dataset.data.map(item => ({
                        x: item.usage,
                        y: item.performance,
                        r: item.importance * 5
                    })),
                    backgroundColor: `${theme.colors[index]}80`,
                    borderColor: theme.colors[index]
                }))
            },
            options: {
                ...this.defaultOptions,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Resource Usage (%)',
                            color: theme.textColor
                        },
                        grid: {
                            color: theme.gridColor
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Performance Score',
                            color: theme.textColor
                        },
                        grid: {
                            color: theme.gridColor
                        }
                    }
                }
            }
        };

        return new Chart(ctx, config);
    }

    // Polar Area Chart for Department Distribution
    createDepartmentDistributionChart(containerId, data, options = {}) {
        const ctx = document.getElementById(containerId).getContext('2d');
        const theme = this.customThemes.get(options.theme || 'light');

        const config = {
            type: 'polarArea',
            data: {
                labels: data.labels,
                datasets: [{
                    data: data.values,
                    backgroundColor: theme.colors.map(color => `${color}80`),
                    borderColor: theme.colors
                }]
            },
            options: {
                ...this.defaultOptions,
                scales: {
                    r: {
                        ticks: {
                            color: theme.textColor
                        },
                        grid: {
                            color: theme.gridColor
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                            color: theme.textColor
                        }
                    }
                }
            }
        };

        return new Chart(ctx, config);
    }

    // Gauge Chart for System Health
    createGaugeChart(containerId, value, options = {}) {
        const ctx = document.getElementById(containerId).getContext('2d');
        const theme = this.customThemes.get(options.theme || 'light');

        const config = {
            type: 'doughnut',
            data: {
                datasets: [{
                    data: [value, 100 - value],
                    backgroundColor: [
                        this.getHealthColor(value),
                        theme.gridColor
                    ],
                    circumference: 180,
                    rotation: 270
                }]
            },
            options: {
                ...this.defaultOptions,
                cutout: '80%',
                plugins: {
                    tooltip: {
                        enabled: false
                    },
                    legend: {
                        display: false
                    }
                }
            },
            plugins: [{
                id: 'gaugeLabel',
                afterDraw: (chart) => {
                    const { width, height } = chart;
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.fillStyle = theme.textColor;
                    ctx.font = 'bold 24px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(
                        `${value}%`,
                        width / 2,
                        height * 0.8
                    );
                    ctx.restore();
                }
            }]
        };

        return new Chart(ctx, config);
    }

    // Multi-Axis Chart for Metrics Comparison
    createMultiAxisChart(containerId, data, options = {}) {
        const ctx = document.getElementById(containerId).getContext('2d');
        const theme = this.customThemes.get(options.theme || 'light');

        const config = {
            type: 'line',
            data: {
                labels: data.labels,
                datasets: data.datasets.map((dataset, index) => ({
                    label: dataset.label,
                    data: dataset.data,
                    borderColor: theme.colors[index],
                    backgroundColor: `${theme.colors[index]}20`,
                    yAxisID: dataset.axis,
                    tension: 0.4,
                    fill: true
                }))
            },
            options: {
                ...this.defaultOptions,
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: theme.textColor
                        }
                    },
                    y1: {
                        type: 'linear',
                        position: 'left',
                        grid: {
                            color: theme.gridColor
                        },
                        ticks: {
                            color: theme.textColor
                        }
                    },
                    y2: {
                        type: 'linear',
                        position: 'right',
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: theme.textColor
                        }
                    }
                }
            }
        };

        return new Chart(ctx, config);
    }

    // Tree Map Chart for Resource Allocation
    createTreeMapChart(containerId, data, options = {}) {
        const ctx = document.getElementById(containerId).getContext('2d');
        const theme = this.customThemes.get(options.theme || 'light');

        // Custom implementation for treemap layout
        const treemapLayout = this.calculateTreemapLayout(data, {
            width: ctx.canvas.width,
            height: ctx.canvas.height
        });

        // Render treemap
        this.renderTreemap(ctx, treemapLayout, theme);
    }

    // Utility Methods
    getHealthColor(value) {
        if (value >= 80) return '#10B981'; // Good
        if (value >= 60) return '#F59E0B'; // Warning
        return '#EF4444'; // Critical
    }

    calculateTreemapLayout(data, dimensions) {
        // Implementation of squarified treemap algorithm
        // Returns layout information for rendering
    }

    renderTreemap(ctx, layout, theme) {
        // Custom rendering of treemap using canvas API
    }

    // Interactive Features
    addChartInteractivity(chart, callbacks) {
        chart.options.onClick = callbacks.onClick;
        chart.options.onHover = callbacks.onHover;
        
        if (callbacks.onLegendClick) {
            chart.options.plugins.legend.onClick = callbacks.onLegendClick;
        }

        chart.update();
    }

    // Animation Effects
    addCustomAnimation(chart, type) {
        const animations = {
            fadeIn: {
                duration: 1000,
                easing: 'easeOutQuart',
                from: 0,
                to: 1
            },
            growUp: {
                duration: 1500,
                easing: 'easeInOutQuart',
                from: 0,
                to: 1,
                loop: false
            }
        };

        chart.options.animation = animations[type];
        chart.update();
    }
}

// Initialize Advanced Chart Manager
const advancedChartManager = new AdvancedChartManager();

// Export Advanced Chart Manager
export { advancedChartManager };

     // Interactive Chart Features and Event Handler System
class ChartInteractionManager {
    constructor() {
        this.eventHandlers = new Map();
        this.tooltipCallbacks = new Map();
        this.customInteractions = new Map();
        this.initializeInteractions();
    }

    // Initialize Default Interactions
    initializeInteractions() {
        // Custom Tooltip Template
        Chart.defaults.plugins.tooltip = {
            ...Chart.defaults.plugins.tooltip,
            backgroundColor: 'rgba(17, 24, 39, 0.95)',
            titleColor: '#fff',
            bodyColor: '#fff',
            borderColor: 'rgba(255, 255, 255, 0.1)',
            borderWidth: 1,
            padding: 12,
            cornerRadius: 8,
            titleFont: {
                size: 14,
                weight: '600',
                family: 'Inter'
            },
            bodyFont: {
                size: 13,
                family: 'Inter'
            },
            displayColors: true,
            boxWidth: 8,
            boxHeight: 8,
            boxPadding: 4,
            usePointStyle: true
        };
    }

    // Add Interactive Features to Chart
    addInteractivity(chart, options = {}) {
        const {
            onClick,
            onHover,
            onLeave,
            tooltipCallbacks,
            zoomEnabled,
            panEnabled,
            drilldownEnabled
        } = options;

        // Click Handler
        if (onClick) {
            chart.options.onClick = (event, elements) => {
                const points = chart.getElementsAtEventForMode(
                    event, 
                    'nearest', 
                    { intersect: true },
                    true
                );
                if (points.length) {
                    onClick(this.getClickData(chart, points[0]));
                }
            };
        }

        // Hover Handler
        if (onHover || onLeave) {
            chart.options.onHover = (event, elements) => {
                const point = elements[0];
                if (point && onHover) {
                    onHover(this.getHoverData(chart, point));
                } else if (!point && onLeave) {
                    onLeave();
                }
                // Update cursor style
                event.native.target.style.cursor = point ? 'pointer' : 'default';
            };
        }

        // Custom Tooltip
        if (tooltipCallbacks) {
            chart.options.plugins.tooltip.callbacks = {
                ...chart.options.plugins.tooltip.callbacks,
                ...tooltipCallbacks
            };
        }

        // Enable Zoom (if requested)
        if (zoomEnabled) {
            this.enableZoom(chart);
        }

        // Enable Pan (if requested)
        if (panEnabled) {
            this.enablePan(chart);
        }

        // Enable Drilldown (if requested)
        if (drilldownEnabled) {
            this.enableDrilldown(chart);
        }

        chart.update();
    }

    // Enable Zoom Functionality
    enableZoom(chart) {
        chart.options.plugins.zoom = {
            zoom: {
                wheel: {
                    enabled: true,
                    modifierKey: 'ctrl'
                },
                pinch: {
                    enabled: true
                },
                mode: 'xy',
                onZoom: (context) => {
                    this.handleZoomEvent(chart, context);
                }
            },
            limits: {
                x: { min: 'original', max: 'original' },
                y: { min: 'original', max: 'original' }
            }
        };
    }

    // Enable Pan Functionality
    enablePan(chart) {
        chart.options.plugins.zoom.pan = {
            enabled: true,
            mode: 'xy',
            threshold: 10,
            onPan: (context) => {
                this.handlePanEvent(chart, context);
            }
        };
    }

    // Enable Drilldown Functionality
    enableDrilldown(chart) {
        this.customInteractions.set(chart.id, {
            drilldownStack: [],
            currentLevel: 0
        });

        chart.options.onClick = (event, elements) => {
            if (elements.length > 0) {
                const element = elements[0];
                this.handleDrilldown(chart, element);
            }
        };
    }

    // Custom Context Menu
    addContextMenu(chart, menuItems) {
        const canvas = chart.canvas;
        
        canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            
            const points = chart.getElementsAtEventForMode(
                event, 
                'nearest', 
                { intersect: true },
                true
            );

            if (points.length) {
                this.showContextMenu(event, points[0], menuItems);
            }
        });
    }

    // Interactive Legend
    enableInteractiveLegend(chart) {
        chart.options.plugins.legend.onClick = (event, legendItem, legend) => {
            const index = legendItem.datasetIndex;
            const type = chart.config.type;

            // Toggle dataset visibility
            const meta = chart.getDatasetMeta(index);
            meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;

            // Special handling for pie/doughnut charts
            if (type === 'pie' || type === 'doughnut') {
                this.handlePieChartLegendClick(chart, legendItem);
            }

            chart.update();
        };

        chart.options.plugins.legend.onHover = (event, legendItem, legend) => {
            const index = legendItem.datasetIndex;
            this.highlightDataset(chart, index);
        };
    }

    // Data Point Highlighting
    enableDataPointHighlight(chart) {
        chart.options.onHover = (event, elements) => {
            if (elements.length) {
                const element = elements[0];
                this.highlightDataPoint(chart, element);
            } else {
                this.resetHighlight(chart);
            }
        };
    }

    // Custom Animations
    addCustomAnimation(chart, type) {
        const animations = {
            fadeIn: {
                duration: 1000,
                easing: 'easeOutQuart',
                from: 0,
                to: 1
            },
            growUp: {
                duration: 1500,
                easing: 'easeInOutQuart',
                from: 0,
                to: 1,
                loop: false
            }
        };

        chart.options.animation = animations[type];
        chart.update();
    }

    // Event Handlers
    handleZoomEvent(chart, context) {
        const { chart: zoomChart } = context;
        // Handle zoom event
        if (this.eventHandlers.has('onZoom')) {
            this.eventHandlers.get('onZoom')(zoomChart);
        }
    }

    handlePanEvent(chart, context) {
        const { chart: panChart } = context;
        // Handle pan event
        if (this.eventHandlers.has('onPan')) {
            this.eventHandlers.get('onPan')(panChart);
        }
    }

    handleDrilldown(chart, element) {
        const drilldownData = this.getDrilldownData(chart, element);
        const interaction = this.customInteractions.get(chart.id);

        // Save current state
        interaction.drilldownStack.push({
            data: chart.data,
            options: chart.options
        });

        // Update chart with drilldown data
        chart.data = drilldownData.data;
        chart.options = {
            ...chart.options,
            ...drilldownData.options
        };

        interaction.currentLevel++;
        chart.update();
    }

    // Utility Methods
    getClickData(chart, element) {
        const datasetIndex = element.datasetIndex;
        const index = element.index;
        const dataset = chart.data.datasets[datasetIndex];

        return {
            label: chart.data.labels[index],
            value: dataset.data[index],
            dataset: dataset.label,
            datasetIndex,
            index
        };
    }

    getHoverData(chart, element) {
        return {
            ...this.getClickData(chart, element),
            x: element.element.x,
            y: element.element.y
        };
    }

    getDrilldownData(chart, element) {
        // Implementation depends on your data structure
        // Return new data and options for drilldown view
    }

    highlightDataset(chart, datasetIndex) {
        chart.data.datasets.forEach((dataset, index) => {
            const meta = chart.getDatasetMeta(index);
            meta.hidden = index !== datasetIndex;
        });
        chart.update();
    }

    highlightDataPoint(chart, element) {
        const { datasetIndex, index } = element;
        
        chart.data.datasets.forEach((dataset, i) => {
            dataset.data.forEach((_, j) => {
                const meta = chart.getDatasetMeta(i);
                const opacity = (i === datasetIndex && j === index) ? 1 : 0.3;
                meta.data[j].options.backgroundColor = this.adjustOpacity(
                    meta.data[j].options.backgroundColor,
                    opacity
                );
            });
        });
        
        chart.update();
    }

    resetHighlight(chart) {
        chart.data.datasets.forEach((dataset, i) => {
            dataset.data.forEach((_, j) => {
                const meta = chart.getDatasetMeta(i);
                meta.data[j].options.backgroundColor = this.adjustOpacity(
                    meta.data[j].options.backgroundColor,
                    1
                );
            });
        });
        
        chart.update();
    }

    adjustOpacity(color, opacity) {
        if (color.startsWith('rgba')) {
            return color.replace(/[\d.]+\)$/g, `${opacity})`);
        }
        return color;
    }
}

// Initialize Chart Interaction Manager
const chartInteractionManager = new ChartInteractionManager();

// Export Chart Interaction Manager
export { chartInteractionManager };

// Chart Data Processing and Transformation Utilities
class ChartDataProcessor {
    constructor() {
        this.processors = new Map();
        this.transformers = new Map();
        this.aggregators = new Map();
        this.initializeProcessors();
    }

    // Initialize Data Processors
    initializeProcessors() {
        // Data Cleaning Processors
        this.processors.set('clean', {
            removeNulls: (data) => data.filter(item => item !== null && item !== undefined),
            removeOutliers: (data, threshold = 2) => {
                const mean = this.calculateMean(data);
                const std = this.calculateStandardDeviation(data);
                return data.filter(item => 
                    Math.abs((item - mean) / std) <= threshold
                );
            },
            fillMissingValues: (data, method = 'mean') => {
                const value = method === 'mean' 
                    ? this.calculateMean(data.filter(x => x !== null))
                    : 0;
                return data.map(item => item === null ? value : item);
            }
        });

        // Data Transformation Processors
        this.transformers.set('transform', {
            normalize: (data) => {
                const min = Math.min(...data);
                const max = Math.max(...data);
                return data.map(value => (value - min) / (max - min));
            },
            standardize: (data) => {
                const mean = this.calculateMean(data);
                const std = this.calculateStandardDeviation(data);
                return data.map(value => (value - mean) / std);
            },
            logarithmic: (data) => {
                return data.map(value => Math.log(Math.max(value, 1)));
            }
        });

        // Data Aggregation Processors
        this.aggregators.set('aggregate', {
            sum: (data) => data.reduce((acc, val) => acc + val, 0),
            average: (data) => this.calculateMean(data),
            median: (data) => {
                const sorted = [...data].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 === 0 
                    ? (sorted[mid - 1] + sorted[mid]) / 2 
                    : sorted[mid];
            }
        });
    }

    // Data Processing Methods
    processChartData(data, options = {}) {
        const {
            cleaning = [],
            transformations = [],
            aggregations = []
        } = options;

        let processedData = this.clone(data);

        // Apply cleaning operations
        if (cleaning.length > 0) {
            processedData = this.applyCleaningOperations(processedData, cleaning);
        }

        // Apply transformations
        if (transformations.length > 0) {
            processedData = this.applyTransformations(processedData, transformations);
        }

        // Apply aggregations
        if (aggregations.length > 0) {
            processedData = this.applyAggregations(processedData, aggregations);
        }

        return processedData;
    }

    // Time Series Data Processing
    processTimeSeriesData(data, options = {}) {
        const {
            interval = 'day',
            aggregation = 'sum',
            fillGaps = true
        } = options;

        // Group data by time interval
        const groupedData = this.groupByTimeInterval(data, interval);

        // Aggregate values within each group
        const aggregatedData = this.aggregateGroups(groupedData, aggregation);

        // Fill gaps if requested
        return fillGaps ? this.fillTimeGaps(aggregatedData, interval) : aggregatedData;
    }

    // Data Transformation Methods
    transformForChart(data, chartType) {
        switch (chartType) {
            case 'line':
                return this.transformForLineChart(data);
            case 'bar':
                return this.transformForBarChart(data);
            case 'pie':
                return this.transformForPieChart(data);
            case 'scatter':
                return this.transformForScatterChart(data);
            default:
                return data;
        }
    }

    // Specific Chart Type Transformations
    transformForLineChart(data) {
        return {
            labels: data.map(item => item.x),
            datasets: [{
                data: data.map(item => item.y),
                borderColor: this.generateColors(1)[0],
                fill: false
            }]
        };
    }

    transformForBarChart(data) {
        return {
            labels: data.map(item => item.label),
            datasets: [{
                data: data.map(item => item.value),
                backgroundColor: this.generateColors(data.length)
            }]
        };
    }

    transformForPieChart(data) {
        return {
            labels: data.map(item => item.label),
            datasets: [{
                data: data.map(item => item.value),
                backgroundColor: this.generateColors(data.length)
            }]
        };
    }

    transformForScatterChart(data) {
        return {
            datasets: [{
                data: data.map(item => ({
                    x: item.x,
                    y: item.y
                })),
                backgroundColor: this.generateColors(1)[0]
            }]
        };
    }

    // Data Analysis Methods
    analyzeData(data) {
        return {
            summary: this.calculateSummaryStatistics(data),
            distribution: this.analyzeDistribution(data),
            trends: this.analyzeTrends(data)
        };
    }

    calculateSummaryStatistics(data) {
        const numericData = data.filter(item => typeof item === 'number');
        return {
            count: numericData.length,
            mean: this.calculateMean(numericData),
            median: this.calculateMedian(numericData),
            std: this.calculateStandardDeviation(numericData),
            min: Math.min(...numericData),
            max: Math.max(...numericData)
        };
    }

    analyzeDistribution(data) {
        const frequencies = new Map();
        data.forEach(value => {
            frequencies.set(value, (frequencies.get(value) || 0) + 1);
        });
        return Array.from(frequencies.entries())
            .map(([value, count]) => ({ value, count }));
    }

    analyzeTrends(data) {
        if (data.length < 2) return null;

        const changes = [];
        for (let i = 1; i < data.length; i++) {
            changes.push(data[i] - data[i - 1]);
        }

        return {
            trend: this.calculateMean(changes) > 0 ? 'increasing' : 'decreasing',
            changeRate: this.calculateMean(changes),
            volatility: this.calculateStandardDeviation(changes)
        };
    }

    // Utility Methods
    calculateMean(data) {
        return data.reduce((acc, val) => acc + val, 0) / data.length;
    }

    calculateMedian(data) {
        const sorted = [...data].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0 
            ? (sorted[mid - 1] + sorted[mid]) / 2 
            : sorted[mid];
    }

    calculateStandardDeviation(data) {
        const mean = this.calculateMean(data);
        const squareDiffs = data.map(value => Math.pow(value - mean, 2));
        return Math.sqrt(this.calculateMean(squareDiffs));
    }

    generateColors(count) {
        const colors = [
            '#4F46E5', '#10B981', '#F59E0B', '#EF4444', 
            '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'
        ];
        return Array(count).fill().map((_, i) => colors[i % colors.length]);
    }

    groupByTimeInterval(data, interval) {
        const groups = new Map();
        data.forEach(item => {
            const key = this.getTimeKey(item.timestamp, interval);
            if (!groups.has(key)) {
                groups.set(key, []);
            }
            groups.get(key).push(item.value);
        });
        return groups;
    }

    getTimeKey(timestamp, interval) {
        const date = new Date(timestamp);
        switch (interval) {
            case 'hour':
                return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}-${date.getHours()}`;
            case 'day':
                return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
            case 'week':
                const weekNumber = Math.ceil((date.getDate() + 1) / 7);
                return `${date.getFullYear()}-${date.getMonth()}-W${weekNumber}`;
            case 'month':
                return `${date.getFullYear()}-${date.getMonth()}`;
            default:
                return timestamp;
        }
    }

    fillTimeGaps(data, interval) {
        const filled = new Map(data);
        const start = Math.min(...Array.from(data.keys()));
        const end = Math.max(...Array.from(data.keys()));
        
        let current = start;
        while (current <= end) {
            if (!filled.has(current)) {
                filled.set(current, 0);
            }
            current = this.incrementTimeKey(current, interval);
        }
        
        return new Map([...filled.entries()].sort());
    }

    incrementTimeKey(key, interval) {
        const date = new Date(key);
        switch (interval) {
            case 'hour':
                date.setHours(date.getHours() + 1);
                break;
            case 'day':
                date.setDate(date.getDate() + 1);
                break;
            case 'week':
                date.setDate(date.getDate() + 7);
                break;
            case 'month':
                date.setMonth(date.getMonth() + 1);
                break;
        }
        return this.getTimeKey(date, interval);
    }

    clone(data) {
        return JSON.parse(JSON.stringify(data));
    }
}

// Initialize Chart Data Processor
const chartDataProcessor = new ChartDataProcessor();

// Export Chart Data Processor
export { chartDataProcessor };   

// Real-time Chart Updates System
class RealTimeChartManager {
    constructor() {
        this.activeCharts = new Map();
        this.updateIntervals = new Map();
        this.dataStreams = new Map();
        this.websocketConnections = new Map();
        this.initializeRealTimeSystem();
    }

    // Initialize Real-time System
    initializeRealTimeSystem() {
        this.setupWebSocketHandler();
        this.setupDataStreamHandler();
        this.setupUpdateHandler();
    }

    // WebSocket Connection Handler
    setupWebSocketHandler() {
        this.wsHandler = {
            connect: (url, options = {}) => {
                const ws = new WebSocket(url);
                
                ws.onopen = () => {
                    console.log('WebSocket connection established');
                    if (options.onConnect) options.onConnect();
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (options.onMessage) options.onMessage(data);
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    if (options.onError) options.onError(error);
                };

                ws.onclose = () => {
                    console.log('WebSocket connection closed');
                    if (options.onClose) options.onClose();
                    // Attempt to reconnect
                    setTimeout(() => this.reconnectWebSocket(url, options), 5000);
                };

                return ws;
            }
        };
    }

    // Real-time Chart Configuration
    configureRealTimeChart(chartId, options = {}) {
        const {
            updateInterval = 1000,
            maxDataPoints = 50,
            dataSource,
            aggregation = 'none',
            animations = true
        } = options;

        const chartConfig = {
            updateInterval,
            maxDataPoints,
            dataSource,
            aggregation,
            animations,
            lastUpdate: Date.now()
        };

        this.activeCharts.set(chartId, chartConfig);
        this.startRealTimeUpdates(chartId);
    }

    // Start Real-time Updates
    startRealTimeUpdates(chartId) {
        const config = this.activeCharts.get(chartId);
        if (!config) return;

        const updateInterval = setInterval(() => {
            this.updateChart(chartId);
        }, config.updateInterval);

        this.updateIntervals.set(chartId, updateInterval);
    }

    // Update Chart with New Data
    async updateChart(chartId) {
        const chart = Chart.getChart(chartId);
        const config = this.activeCharts.get(chartId);
        if (!chart || !config) return;

        try {
            const newData = await this.fetchNewData(config.dataSource);
            this.processAndUpdateChart(chart, newData, config);
        } catch (error) {
            console.error('Error updating chart:', error);
            this.handleUpdateError(chartId, error);
        }
    }

    // Process and Update Chart Data
    processAndUpdateChart(chart, newData, config) {
        const { maxDataPoints, aggregation, animations } = config;

        // Process new data based on aggregation method
        const processedData = this.aggregateData(newData, aggregation);

        // Update datasets
        chart.data.datasets.forEach((dataset, index) => {
            // Add new data
            dataset.data.push(...(processedData[index] || []));

            // Remove old data if exceeding maxDataPoints
            if (dataset.data.length > maxDataPoints) {
                dataset.data.splice(0, dataset.data.length - maxDataPoints);
            }
        });

        // Update labels if necessary
        if (chart.data.labels) {
            const newLabels = this.generateLabels(processedData);
            chart.data.labels = this.updateLabels(chart.data.labels, newLabels, maxDataPoints);
        }

        // Update chart with animation options
        chart.update(animations ? 'active' : 'none');
    }

    // WebSocket Data Streaming
    setupDataStream(chartId, websocketUrl, options = {}) {
        const ws = this.wsHandler.connect(websocketUrl, {
            onMessage: (data) => {
                this.handleStreamData(chartId, data);
            },
            ...options
        });

        this.websocketConnections.set(chartId, ws);
    }

    // Handle Streaming Data
    handleStreamData(chartId, data) {
        const chart = Chart.getChart(chartId);
        const config = this.activeCharts.get(chartId);
        if (!chart || !config) return;

        // Process streaming data
        const processedData = this.processStreamData(data, config);
        
        // Update chart with new data
        this.updateChartWithStreamData(chart, processedData, config);
    }

    // Real-time Data Processing
    processStreamData(data, config) {
        const { aggregation } = config;

        switch (aggregation) {
            case 'sum':
                return this.aggregateSum(data);
            case 'average':
                return this.aggregateAverage(data);
            case 'max':
                return this.aggregateMax(data);
            case 'min':
                return this.aggregateMin(data);
            default:
                return data;
        }
    }

    // Update Chart with Stream Data
    updateChartWithStreamData(chart, data, config) {
        const { maxDataPoints, animations } = config;

        // Update each dataset
        chart.data.datasets.forEach((dataset, index) => {
            // Add new data point
            if (Array.isArray(data)) {
                dataset.data.push(data[index]);
            } else {
                dataset.data.push(data);
            }

            // Remove oldest data point if exceeding maxDataPoints
            if (dataset.data.length > maxDataPoints) {
                dataset.data.shift();
            }
        });

        // Update labels for time-series data
        if (chart.data.labels) {
            const newLabel = new Date().toLocaleTimeString();
            chart.data.labels.push(newLabel);
            if (chart.data.labels.length > maxDataPoints) {
                chart.data.labels.shift();
            }
        }

        // Update chart
        chart.update(animations ? 'active' : 'none');
    }

    // Data Aggregation Methods
    aggregateData(data, method) {
        switch (method) {
            case 'sum':
                return data.reduce((acc, val) => acc + val, 0);
            case 'average':
                return data.reduce((acc, val) => acc + val, 0) / data.length;
            case 'max':
                return Math.max(...data);
            case 'min':
                return Math.min(...data);
            default:
                return data;
        }
    }

    // Error Handling
    handleUpdateError(chartId, error) {
        const chart = Chart.getChart(chartId);
        if (!chart) return;

        // Add error indicator to chart
        chart.options.plugins.tooltip.callbacks.footer = (tooltipItems) => {
            return 'Last update failed';
        };

        // Update chart status
        this.activeCharts.get(chartId).status = 'error';
        
        // Emit error event
        this.emitChartEvent(chartId, 'error', error);
    }

    // Event Handling
    emitChartEvent(chartId, eventType, data) {
        const event = new CustomEvent(`chart:${eventType}`, {
            detail: {
                chartId,
                data
            }
        });
        window.dispatchEvent(event);
    }

    // Cleanup Methods
    stopRealTimeUpdates(chartId) {
        // Clear update interval
        const interval = this.updateIntervals.get(chartId);
        if (interval) {
            clearInterval(interval);
            this.updateIntervals.delete(chartId);
        }

        // Close WebSocket connection
        const ws = this.websocketConnections.get(chartId);
        if (ws) {
            ws.close();
            this.websocketConnections.delete(chartId);
        }

        // Remove chart configuration
        this.activeCharts.delete(chartId);
    }

    // Utility Methods
    generateLabels(data) {
        return data.map(() => new Date().toLocaleTimeString());
    }

    updateLabels(currentLabels, newLabels, maxPoints) {
        const updatedLabels = [...currentLabels, ...newLabels];
        return updatedLabels.slice(-maxPoints);
    }

    reconnectWebSocket(url, options) {
        console.log('Attempting to reconnect WebSocket...');
        this.wsHandler.connect(url, options);
    }
}

// Initialize Real-time Chart Manager
const realTimeChartManager = new RealTimeChartManager();

// Example Usage
const initializeRealTimeChart = (chartId, options) => {
    realTimeChartManager.configureRealTimeChart(chartId, {
        updateInterval: 1000,
        maxDataPoints: 50,
        dataSource: 'api/real-time-data',
        aggregation: 'average',
        animations: true,
        ...options
    });
};

// Export Real-time Chart Manager
export { realTimeChartManager, initializeRealTimeChart };     

// Advanced Chart Customization System
class ChartCustomizationManager {
    constructor() {
        this.themes = new Map();
        this.customStyles = new Map();
        this.animations = new Map();
        this.gradients = new Map();
        this.patterns = new Map();
        this.initializeCustomizations();
    }

    // Initialize Default Customizations
    initializeCustomizations() {
        this.initializeThemes();
        this.initializeAnimations();
        this.initializePatterns();
        this.initializeGradients();
    }

    // Theme Management
    initializeThemes() {
        // Corporate Theme
        this.themes.set('corporate', {
            colors: ['#2563EB', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'],
            backgroundColor: '#FFFFFF',
            fontFamily: 'Inter, sans-serif',
            fontSize: 13,
            gridLines: {
                color: 'rgba(0, 0, 0, 0.05)',
                borderDash: []
            },
            tooltips: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#FFFFFF',
                bodyColor: '#FFFFFF',
                borderColor: 'rgba(255, 255, 255, 0.1)',
                borderWidth: 1
            }
        });

        // Dark Theme
        this.themes.set('dark', {
            colors: ['#818CF8', '#34D399', '#FBBF24', '#F87171', '#A78BFA'],
            backgroundColor: '#1F2937',
            fontFamily: 'Inter, sans-serif',
            fontSize: 13,
            gridLines: {
                color: 'rgba(255, 255, 255, 0.1)',
                borderDash: []
            },
            tooltips: {
                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                titleColor: '#FFFFFF',
                bodyColor: '#FFFFFF',
                borderColor: 'rgba(255, 255, 255, 0.2)',
                borderWidth: 1
            }
        });

        // Modern Theme
        this.themes.set('modern', {
            colors: ['#06B6D4', '#8B5CF6', '#EC4899', '#10B981', '#F59E0B'],
            backgroundColor: '#F8FAFC',
            fontFamily: 'Plus Jakarta Sans, sans-serif',
            fontSize: 13,
            gridLines: {
                color: 'rgba(0, 0, 0, 0.03)',
                borderDash: [5, 5]
            },
            tooltips: {
                backgroundColor: 'rgba(0, 0, 0, 0.85)',
                titleColor: '#FFFFFF',
                bodyColor: '#FFFFFF',
                borderColor: 'rgba(255, 255, 255, 0.15)',
                borderWidth: 0
            }
        });
    }

    // Apply Theme to Chart
    applyTheme(chart, themeName) {
        const theme = this.themes.get(themeName);
        if (!theme) return;

        chart.options = this.mergeDeep(chart.options, {
            plugins: {
                legend: {
                    labels: {
                        font: {
                            family: theme.fontFamily,
                            size: theme.fontSize
                        },
                        color: theme.backgroundColor === '#FFFFFF' ? '#1F2937' : '#FFFFFF'
                    }
                },
                tooltip: {
                    backgroundColor: theme.tooltips.backgroundColor,
                    titleColor: theme.tooltips.titleColor,
                    bodyColor: theme.tooltips.bodyColor,
                    borderColor: theme.tooltips.borderColor,
                    borderWidth: theme.tooltips.borderWidth,
                    padding: 12,
                    cornerRadius: 6,
                    titleFont: {
                        family: theme.fontFamily,
                        size: theme.fontSize + 1
                    },
                    bodyFont: {
                        family: theme.fontFamily,
                        size: theme.fontSize
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        color: theme.gridLines.color,
                        borderDash: theme.gridLines.borderDash
                    },
                    ticks: {
                        font: {
                            family: theme.fontFamily,
                            size: theme.fontSize
                        },
                        color: theme.backgroundColor === '#FFFFFF' ? '#1F2937' : '#FFFFFF'
                    }
                },
                y: {
                    grid: {
                        color: theme.gridLines.color,
                        borderDash: theme.gridLines.borderDash
                    },
                    ticks: {
                        font: {
                            family: theme.fontFamily,
                            size: theme.fontSize
                        },
                        color: theme.backgroundColor === '#FFFFFF' ? '#1F2937' : '#FFFFFF'
                    }
                }
            }
        });

        // Update dataset colors
        chart.data.datasets.forEach((dataset, index) => {
            dataset.backgroundColor = theme.colors[index % theme.colors.length];
            if (chart.config.type === 'line') {
                dataset.borderColor = theme.colors[index % theme.colors.length];
            }
        });

        chart.update();
    }

    // Custom Gradient Backgrounds
    createGradient(ctx, colors, direction = 'vertical') {
        const gradient = direction === 'vertical' 
            ? ctx.createLinearGradient(0, 0, 0, ctx.canvas.height)
            : ctx.createLinearGradient(0, 0, ctx.canvas.width, 0);

        colors.forEach((color, index) => {
            gradient.addColorStop(index / (colors.length - 1), color);
        });

        return gradient;
    }

    // Custom Pattern Backgrounds
    createPattern(type, colors) {
        const patternCanvas = document.createElement('canvas');
        const patternCtx = patternCanvas.getContext('2d');
        
        patternCanvas.width = 20;
        patternCanvas.height = 20;

        switch (type) {
            case 'dots':
                this.drawDotPattern(patternCtx, colors);
                break;
            case 'stripes':
                this.drawStripePattern(patternCtx, colors);
                break;
            case 'grid':
                this.drawGridPattern(patternCtx, colors);
                break;
            // Add more pattern types as needed
        }

        return patternCanvas;
    }

    // Custom Animations
    addCustomAnimation(chart, type) {
        const animations = {
            fadeIn: {
                duration: 1000,
                easing: 'easeOutQuart',
                from: 0,
                to: 1
            },
            slideIn: {
                duration: 1000,
                easing: 'easeOutExpo',
                from: {
                    x: -100,
                    opacity: 0
                },
                to: {
                    x: 0,
                    opacity: 1
                }
            },
            growUp: {
                duration: 1500,
                easing: 'easeInOutQuart',
                from: {
                    y: 100,
                    opacity: 0
                },
                to: {
                    y: 0,
                    opacity: 1
                }
            }
        };

        chart.options.animation = animations[type];
        chart.update();
    }

    // Custom Styling Methods
    applyCustomStyle(chart, style) {
        const styles = {
            modern: {
                borderRadius: 8,
                borderWidth: 0,
                hoverOffset: 10
            },
            classic: {
                borderRadius: 0,
                borderWidth: 2,
                hoverOffset: 5
            },
            minimal: {
                borderRadius: 4,
                borderWidth: 1,
                hoverOffset: 7
            }
        };

        chart.data.datasets.forEach(dataset => {
            Object.assign(dataset, styles[style]);
        });

        chart.update();
    }

    // Legend Customization
    customizeLegend(chart, options) {
        chart.options.plugins.legend = {
            ...chart.options.plugins.legend,
            position: options.position || 'top',
            align: options.align || 'center',
            labels: {
                usePointStyle: options.usePointStyle || false,
                padding: options.padding || 20,
                font: {
                    family: options.fontFamily || 'Inter',
                    size: options.fontSize || 12,
                    weight: options.fontWeight || 'normal'
                },
                generateLabels: (chart) => {
                    // Custom label generation logic
                    return chart.data.labels.map((label, index) => ({
                        text: label,
                        fillStyle: chart.data.datasets[0].backgroundColor[index],
                        strokeStyle: chart.data.datasets[0].backgroundColor[index],
                        lineWidth: 0,
                        hidden: false,
                        index: index
                    }));
                }
            },
            onClick: (e, legendItem, legend) => {
                // Custom click handler
                const index = legendItem.index;
                const ci = legend.chart;
                
                if (ci.isDatasetVisible(index)) {
                    ci.hide(index);
                    legendItem.hidden = true;
                } else {
                    ci.show(index);
                    legendItem.hidden = false;
                }
            }
        };

        chart.update();
    }

    // Tooltip Customization
    customizeTooltip(chart, options) {
        chart.options.plugins.tooltip = {
            ...chart.options.plugins.tooltip,
            enabled: true,
            mode: options.mode || 'index',
            intersect: options.intersect || false,
            backgroundColor: options.backgroundColor || 'rgba(0, 0, 0, 0.8)',
            titleColor: options.titleColor || '#FFFFFF',
            bodyColor: options.bodyColor || '#FFFFFF',
            borderColor: options.borderColor || 'rgba(255, 255, 255, 0.1)',
            borderWidth: options.borderWidth || 1,
            padding: options.padding || 12,
            cornerRadius: options.cornerRadius || 6,
            usePointStyle: options.usePointStyle || true,
            callbacks: {
                title: (tooltipItems) => {
                    // Custom title formatting
                    return options.titleFormatter 
                        ? options.titleFormatter(tooltipItems)
                        : tooltipItems[0].label;
                },
                label: (context) => {
                    // Custom label formatting
                    return options.labelFormatter 
                        ? options.labelFormatter(context)
                        : `${context.dataset.label}: ${context.formattedValue}`;
                }
            }
        };

        chart.update();
    }

    // Utility Methods
    mergeDeep(target, source) {
        const isObject = (obj) => obj && typeof obj === 'object';
        
        if (!isObject(target) || !isObject(source)) {
            return source;
        }

        Object.keys(source).forEach(key => {
            const targetValue = target[key];
            const sourceValue = source[key];

            if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
                target[key] = targetValue.concat(sourceValue);
            } else if (isObject(targetValue) && isObject(sourceValue)) {
                target[key] = this.mergeDeep(Object.assign({}, targetValue), sourceValue);
            } else {
                target[key] = sourceValue;
            }
        });

        return target;
    }
}

// Initialize Chart Customization Manager
const chartCustomizer = new ChartCustomizationManager();

// Export Chart Customization Manager
export { chartCustomizer };

 // Chart Export and Advanced Visualization System
class ChartExportAndVisualizationManager {
    constructor() {
        this.exportFormats = new Map();
        this.visualizationTechniques = new Map();
        this.sharingOptions = new Map();
        this.initializeSystem();
    }

    // Initialize Export and Visualization Systems
    initializeSystem() {
        this.initializeExportFormats();
        this.initializeVisualizationTechniques();
        this.initializeSharingOptions();
    }

    // Export Features
    initializeExportFormats() {
        this.exportFormats = {
            // Image Export Options
            image: {
                png: {
                    export: async (chart, options = {}) => {
                        const canvas = chart.canvas;
                        const dataUrl = canvas.toDataURL('image/png', options.quality || 1.0);
                        if (options.download) {
                            this.downloadFile(dataUrl, `${chart.id || 'chart'}.png`);
                        }
                        return dataUrl;
                    }
                },
                jpeg: {
                    export: async (chart, options = {}) => {
                        const canvas = chart.canvas;
                        const dataUrl = canvas.toDataURL('image/jpeg', options.quality || 0.9);
                        if (options.download) {
                            this.downloadFile(dataUrl, `${chart.id || 'chart'}.jpg`);
                        }
                        return dataUrl;
                    }
                },
                svg: {
                    export: async (chart, options = {}) => {
                        const svgString = this.chartToSVG(chart);
                        const dataUrl = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgString)}`;
                        if (options.download) {
                            this.downloadFile(dataUrl, `${chart.id || 'chart'}.svg`);
                        }
                        return dataUrl;
                    }
                }
            },

            // Data Export Options
            data: {
                csv: {
                    export: async (chart, options = {}) => {
                        const csvData = this.chartToCSV(chart);
                        const dataUrl = `data:text/csv;charset=utf-8,${encodeURIComponent(csvData)}`;
                        if (options.download) {
                            this.downloadFile(dataUrl, `${chart.id || 'chart'}.csv`);
                        }
                        return csvData;
                    }
                },
                excel: {
                    export: async (chart, options = {}) => {
                        const workbook = this.chartToExcel(chart);
                        const buffer = await workbook.xlsx.writeBuffer();
                        const blob = new Blob([buffer], { 
                            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
                        });
                        if (options.download) {
                            this.downloadBlob(blob, `${chart.id || 'chart'}.xlsx`);
                        }
                        return blob;
                    }
                },
                json: {
                    export: async (chart, options = {}) => {
                        const jsonData = this.chartToJSON(chart);
                        if (options.download) {
                            const blob = new Blob([JSON.stringify(jsonData, null, 2)], 
                                { type: 'application/json' });
                            this.downloadBlob(blob, `${chart.id || 'chart'}.json`);
                        }
                        return jsonData;
                    }
                }
            },

            // PDF Export Options
            pdf: {
                export: async (chart, options = {}) => {
                    const pdf = await this.chartToPDF(chart, options);
                    if (options.download) {
                        pdf.save(`${chart.id || 'chart'}.pdf`);
                    }
                    return pdf;
                }
            }
        };
    }

    // Advanced Visualization Techniques
    initializeVisualizationTechniques() {
        this.visualizationTechniques = {
            // Advanced Chart Types
            advancedTypes: {
                // Sunburst Chart
                sunburst: {
                    create: (data, options) => {
                        return this.createSunburstChart(data, options);
                    }
                },
                // Sankey Diagram
                sankey: {
                    create: (data, options) => {
                        return this.createSankeyDiagram(data, options);
                    }
                },
                // Force Directed Graph
                forceGraph: {
                    create: (data, options) => {
                        return this.createForceGraph(data, options);
                    }
                },
                // Treemap
                treemap: {
                    create: (data, options) => {
                        return this.createTreemap(data, options);
                    }
                },
                // Heatmap
                heatmap: {
                    create: (data, options) => {
                        return this.createHeatmap(data, options);
                    }
                }
            },

            // Data Visualization Enhancements
            enhancements: {
                // Trend Lines
                trendLine: {
                    add: (chart, type = 'linear') => {
                        return this.addTrendLine(chart, type);
                    }
                },
                // Moving Averages
                movingAverage: {
                    add: (chart, period = 7) => {
                        return this.addMovingAverage(chart, period);
                    }
                },
                // Confidence Intervals
                confidenceInterval: {
                    add: (chart, confidence = 0.95) => {
                        return this.addConfidenceInterval(chart, confidence);
                    }
                }
            },

            // Interactive Features
            interactivity: {
                // Drill Down
                drillDown: {
                    enable: (chart, levels) => {
                        return this.enableDrillDown(chart, levels);
                    }
                },
                // Cross Filtering
                crossFilter: {
                    enable: (charts) => {
                        return this.enableCrossFiltering(charts);
                    }
                },
                // Brushing and Linking
                brushing: {
                    enable: (charts) => {
                        return this.enableBrushing(charts);
                    }
                }
            }
        };
    }

    // Sharing Options
    initializeSharingOptions() {
        this.sharingOptions = {
            // Embed Code Generation
            embed: {
                generate: (chart, options) => {
                    return this.generateEmbedCode(chart, options);
                }
            },
            // Share Link Generation
            link: {
                generate: (chart, options) => {
                    return this.generateShareLink(chart, options);
                }
            },
            // Social Media Sharing
            social: {
                share: (chart, platform, options) => {
                    return this.shareToSocial(chart, platform, options);
                }
            }
        };
    }

    // Advanced Visualization Implementation Methods
    createSunburstChart(data, options) {
        // Implementation for sunburst chart
    }

    createSankeyDiagram(data, options) {
        // Implementation for sankey diagram
    }

    createForceGraph(data, options) {
        // Implementation for force directed graph
    }

    createTreemap(data, options) {
        // Implementation for treemap
    }

    createHeatmap(data, options) {
        // Implementation for heatmap
    }

    // Enhancement Implementation Methods
    addTrendLine(chart, type) {
        // Implementation for trend line
    }

    addMovingAverage(chart, period) {
        // Implementation for moving average
    }

    addConfidenceInterval(chart, confidence) {
        // Implementation for confidence interval
    }

    // Export Implementation Methods
    chartToSVG(chart) {
        // Implementation for SVG conversion
    }

    chartToCSV(chart) {
        // Implementation for CSV conversion
    }

    chartToExcel(chart) {
        // Implementation for Excel conversion
    }

    chartToJSON(chart) {
        // Implementation for JSON conversion
    }

    chartToPDF(chart, options) {
        // Implementation for PDF conversion
    }

    // Utility Methods
    downloadFile(dataUrl, filename) {
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    downloadBlob(blob, filename) {
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
    }

    // Sharing Implementation Methods
    generateEmbedCode(chart, options) {
        // Implementation for embed code generation
    }

    generateShareLink(chart, options) {
        // Implementation for share link generation
    }

    shareToSocial(chart, platform, options) {
        // Implementation for social media sharing
    }
}

// Initialize Export and Visualization Manager
const chartExportManager = new ChartExportAndVisualizationManager();

// Export Manager
export { chartExportManager };    

     // Performance Optimization and Advanced Visualization System
class ChartOptimizationManager {
    constructor() {
        this.optimizationStrategies = new Map();
        this.renderingQueue = new Map();
        this.dataCache = new Map();
        this.initializeOptimizations();
    }

    // Performance Optimization Strategies
    initializeOptimizations() {
        // Data Management Optimizations
        this.optimizationStrategies.set('data', {
            // Data Chunking
            chunkData: (data, chunkSize = 1000) => {
                return Array.from({ length: Math.ceil(data.length / chunkSize) }, (_, i) =>
                    data.slice(i * chunkSize, (i + 1) * chunkSize)
                );
            },

            // Data Decimation
            decimateData: (data, factor) => {
                return data.filter((_, index) => index % factor === 0);
            },

            // Data Aggregation
            aggregateData: (data, interval) => {
                const aggregated = {};
                data.forEach(item => {
                    const key = Math.floor(item.x / interval) * interval;
                    if (!aggregated[key]) {
                        aggregated[key] = { sum: 0, count: 0 };
                    }
                    aggregated[key].sum += item.y;
                    aggregated[key].count++;
                });

                return Object.entries(aggregated).map(([x, { sum, count }]) => ({
                    x: Number(x),
                    y: sum / count
                }));
            }
        });

        // Rendering Optimizations
        this.optimizationStrategies.set('rendering', {
            // RAF Manager
            requestAnimationFrameManager: () => {
                let ticking = false;
                return (callback) => {
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            callback();
                            ticking = false;
                        });
                        ticking = true;
                    }
                };
            },

            // Canvas Layer Management
            layerManager: (chart) => {
                const layers = new Map();
                const mainCanvas = chart.canvas;
                
                return {
                    createLayer: (name) => {
                        const canvas = document.createElement('canvas');
                        canvas.width = mainCanvas.width;
                        canvas.height = mainCanvas.height;
                        layers.set(name, canvas);
                        return canvas;
                    },
                    
                    updateLayer: (name, drawCallback) => {
                        const canvas = layers.get(name);
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            drawCallback(ctx);
                        }
                    },
                    
                    composeLayers: () => {
                        const ctx = mainCanvas.getContext('2d');
                        ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                        layers.forEach(canvas => {
                            ctx.drawImage(canvas, 0, 0);
                        });
                    }
                };
            },

            // WebGL Rendering
            webglRenderer: (chart) => {
                // WebGL initialization and rendering logic
                const gl = chart.canvas.getContext('webgl');
                // ... WebGL setup code ...
                
                return {
                    render: (data) => {
                        // WebGL rendering implementation
                    }
                };
            }
        });

        // Memory Management
        this.optimizationStrategies.set('memory', {
            // Memory Pool
            createMemoryPool: (initialSize = 1000) => {
                const pool = new Array(initialSize);
                let currentIndex = 0;

                return {
                    acquire: () => {
                        if (currentIndex >= pool.length) {
                            pool.length *= 2;
                        }
                        return pool[currentIndex++];
                    },
                    release: (index) => {
                        currentIndex = Math.min(currentIndex - 1, index);
                    },
                    reset: () => {
                        currentIndex = 0;
                    }
                };
            },

            // Garbage Collection Helper
            gcHelper: () => {
                let gcTimeout;
                return {
                    scheduleGC: () => {
                        if (gcTimeout) clearTimeout(gcTimeout);
                        gcTimeout = setTimeout(() => {
                            if (global.gc) {
                                global.gc();
                            }
                        }, 1000);
                    }
                };
            }
        });
    }

    // Performance Monitoring
    monitorPerformance(chart) {
        const metrics = {
            fps: 0,
            renderTime: 0,
            memoryUsage: 0,
            dataPoints: 0
        };

        let lastTime = performance.now();
        let frames = 0;

        const update = () => {
            const now = performance.now();
            frames++;

            if (now - lastTime >= 1000) {
                metrics.fps = frames;
                frames = 0;
                lastTime = now;

                // Update other metrics
                metrics.dataPoints = this.countDataPoints(chart);
                metrics.memoryUsage = this.getMemoryUsage();

                this.updatePerformanceDisplay(metrics);
            }

            requestAnimationFrame(update);
        };

        update();
        return metrics;
    }

    // Optimization Implementation
    optimizeChart(chart, options = {}) {
        const {
            dataOptimization = true,
            renderingOptimization = true,
            memoryOptimization = true
        } = options;

        if (dataOptimization) {
            this.applyDataOptimizations(chart);
        }

        if (renderingOptimization) {
            this.applyRenderingOptimizations(chart);
        }

        if (memoryOptimization) {
            this.applyMemoryOptimizations(chart);
        }

        return chart;
    }

    // Data Optimization Implementation
    applyDataOptimizations(chart) {
        const dataPoints = this.countDataPoints(chart);

        // Apply different strategies based on data size
        if (dataPoints > 10000) {
            // Use decimation for large datasets
            chart.data.datasets.forEach(dataset => {
                dataset.data = this.optimizationStrategies.get('data')
                    .decimateData(dataset.data, Math.ceil(dataPoints / 10000));
            });
        } else if (dataPoints > 1000) {
            // Use aggregation for medium datasets
            chart.data.datasets.forEach(dataset => {
                dataset.data = this.optimizationStrategies.get('data')
                    .aggregateData(dataset.data, Math.ceil(dataPoints / 1000));
            });
        }

        // Enable data chunking for updates
        const chunkManager = this.optimizationStrategies.get('data').chunkData;
        chart.options.plugins.streaming = {
            ...chart.options.plugins.streaming,
            onRefresh: (chart) => {
                const newData = this.getNewData(); // Your data fetching logic
                const chunks = chunkManager(newData);
                chunks.forEach((chunk, i) => {
                    setTimeout(() => {
                        this.updateChartData(chart, chunk);
                    }, i * 16); // Spread updates across frames
                });
            }
        };
    }

    // Rendering Optimization Implementation
    applyRenderingOptimizations(chart) {
        // Create layer manager
        const layerManager = this.optimizationStrategies.get('rendering')
            .layerManager(chart);

        // Create separate layers for different chart elements
        const dataLayer = layerManager.createLayer('data');
        const axisLayer = layerManager.createLayer('axis');
        const overlayLayer = layerManager.createLayer('overlay');

        // Override chart render function
        const originalRender = chart.render;
        chart.render = function() {
            // Update layers
            layerManager.updateLayer('axis', (ctx) => {
                this.drawAxis(ctx);
            });

            layerManager.updateLayer('data', (ctx) => {
                this.drawDatasets(ctx);
            });

            layerManager.updateLayer('overlay', (ctx) => {
                this.drawOverlay(ctx);
            });

            // Compose final image
            layerManager.composeLayers();
        };

        // Add RAF manager
        const rafManager = this.optimizationStrategies.get('rendering')
            .requestAnimationFrameManager();

        chart.update = function(config) {
            rafManager(() => {
                originalRender.call(this, config);
            });
        };
    }

    // Memory Optimization Implementation
    applyMemoryOptimizations(chart) {
        // Create memory pool
        const memoryPool = this.optimizationStrategies.get('memory')
            .createMemoryPool();

        // Create GC helper
        const gcHelper = this.optimizationStrategies.get('memory')
            .gcHelper();

        // Override data update functions
        const originalUpdate = chart.update;
        chart.update = function(config) {
            // Release old data
            memoryPool.reset();

            // Update chart
            originalUpdate.call(this, config);

            // Schedule GC
            gcHelper.scheduleGC();
        };
    }

    // Utility Methods
    countDataPoints(chart) {
        return chart.data.datasets.reduce((total, dataset) => 
            total + dataset.data.length, 0);
    }

    getMemoryUsage() {
        return performance.memory ? 
            performance.memory.usedJSHeapSize : 
            0;
    }

    updatePerformanceDisplay(metrics) {
        // Implementation for updating performance metrics display
    }
}

// Initialize Optimization Manager
const chartOptimizationManager = new ChartOptimizationManager();

// Export Manager
export { chartOptimizationManager };

     // Advanced Customization and Visualization Techniques
class AdvancedVisualizationManager {
    constructor() {
        this.customVisuals = new Map();
        this.templates = new Map();
        this.effects = new Map();
        this.initializeVisuals();
    }

    // Initialize Advanced Visualizations
    initializeVisuals() {
        this.initializeSunburstChart();
        this.initializeHeatmap();
        this.initializeTreemap();
        this.initializeNetworkGraph();
        this.initializeCustomEffects();
    }

    // Sunburst Chart Implementation
    initializeSunburstChart() {
        this.customVisuals.set('sunburst', {
            create: (container, data, options = {}) => {
                const width = options.width || 600;
                const height = options.height || 600;
                const radius = Math.min(width, height) / 2;

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g')
                    .attr('transform', `translate(${width / 2},${height / 2})`);

                const partition = d3.partition()
                    .size([2 * Math.PI, radius]);

                const root = d3.hierarchy(data)
                    .sum(d => d.value)
                    .sort((a, b) => b.value - a.value);

                const arc = d3.arc()
                    .startAngle(d => d.x0)
                    .endAngle(d => d.x1)
                    .innerRadius(d => d.y0)
                    .outerRadius(d => d.y1);

                const color = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, data.children.length + 1));

                const paths = svg.selectAll('path')
                    .data(partition(root).descendants())
                    .enter()
                    .append('path')
                    .attr('d', arc)
                    .style('fill', d => color((d.children ? d : d.parent).data.name))
                    .style('opacity', 0.8)
                    .on('mouseover', this.handleSunburstHover)
                    .on('mouseout', this.handleSunburstOut);

                if (options.animation) {
                    this.animateSunburst(paths);
                }

                return {
                    update: (newData) => this.updateSunburst(svg, newData, options),
                    destroy: () => svg.remove()
                };
            }
        });
    }

    // Heatmap Implementation
    initializeHeatmap() {
        this.customVisuals.set('heatmap', {
            create: (container, data, options = {}) => {
                const margin = options.margin || { top: 20, right: 20, bottom: 30, left: 40 };
                const width = options.width - margin.left - margin.right;
                const height = options.height - margin.top - margin.bottom;

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom)
                    .append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                const x = d3.scaleBand()
                    .range([0, width])
                    .domain(data.map(d => d.x));

                const y = d3.scaleBand()
                    .range([height, 0])
                    .domain(data.map(d => d.y));

                const color = d3.scaleSequential()
                    .interpolator(d3.interpolateInferno)
                    .domain([0, d3.max(data, d => d.value)]);

                const cells = svg.selectAll('rect')
                    .data(data)
                    .enter()
                    .append('rect')
                    .attr('x', d => x(d.x))
                    .attr('y', d => y(d.y))
                    .attr('width', x.bandwidth())
                    .attr('height', y.bandwidth())
                    .style('fill', d => color(d.value))
                    .on('mouseover', this.handleHeatmapHover)
                    .on('mouseout', this.handleHeatmapOut);

                if (options.animation) {
                    this.animateHeatmap(cells);
                }

                return {
                    update: (newData) => this.updateHeatmap(svg, newData, options),
                    destroy: () => svg.remove()
                };
            }
        });
    }

    // Network Graph Implementation
    initializeNetworkGraph() {
        this.customVisuals.set('network', {
            create: (container, data, options = {}) => {
                const width = options.width || 800;
                const height = options.height || 600;

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const simulation = d3.forceSimulation(data.nodes)
                    .force('link', d3.forceLink(data.links).id(d => d.id))
                    .force('charge', d3.forceManyBody())
                    .force('center', d3.forceCenter(width / 2, height / 2));

                const link = svg.append('g')
                    .selectAll('line')
                    .data(data.links)
                    .enter()
                    .append('line')
                    .style('stroke', '#999')
                    .style('stroke-opacity', 0.6)
                    .style('stroke-width', d => Math.sqrt(d.value));

                const node = svg.append('g')
                    .selectAll('circle')
                    .data(data.nodes)
                    .enter()
                    .append('circle')
                    .attr('r', 5)
                    .style('fill', d => d.color || '#69b3a2')
                    .call(this.dragBehavior(simulation));

                simulation.on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                });

                return {
                    simulation,
                    update: (newData) => this.updateNetwork(simulation, newData),
                    destroy: () => {
                        simulation.stop();
                        svg.remove();
                    }
                };
            }
        });
    }

    // Custom Effects Implementation
    initializeCustomEffects() {
        this.effects.set('glow', {
            apply: (element, options = {}) => {
                const filter = element.append('defs')
                    .append('filter')
                    .attr('id', 'glow');

                filter.append('feGaussianBlur')
                    .attr('stdDeviation', options.strength || 3)
                    .attr('result', 'coloredBlur');

                const feMerge = filter.append('feMerge');
                feMerge.append('feMergeNode')
                    .attr('in', 'coloredBlur');
                feMerge.append('feMergeNode')
                    .attr('in', 'SourceGraphic');

                element.style('filter', 'url(#glow)');
            }
        });

        this.effects.set('gradient', {
            apply: (element, options = {}) => {
                const gradient = element.append('defs')
                    .append('linearGradient')
                    .attr('id', options.id || 'gradient')
                    .attr('x1', '0%')
                    .attr('y1', '0%')
                    .attr('x2', '100%')
                    .attr('y2', '100%');

                gradient.append('stop')
                    .attr('offset', '0%')
                    .attr('style', `stop-color:${options.startColor || '#ff0000'}`);

                gradient.append('stop')
                    .attr('offset', '100%')
                    .attr('style', `stop-color:${options.endColor || '#00ff00'}`);

                element.style('fill', `url(#${options.id || 'gradient'})`);
            }
        });
    }

    // Animation Methods
    animateSunburst(paths) {
        paths.transition()
            .duration(1000)
            .attrTween('d', d => {
                const interpolate = d3.interpolate(
                    { x0: 0, x1: 0, y0: 0, y1: 0 },
                    { x0: d.x0, x1: d.x1, y0: d.y0, y1: d.y1 }
                );
                return t => arc(interpolate(t));
            });
    }

    animateHeatmap(cells) {
        cells.style('opacity', 0)
            .transition()
            .duration(750)
            .style('opacity', 1);
    }

    // Event Handlers
    handleSunburstHover(event, d) {
        d3.select(this)
            .transition()
            .duration(200)
            .style('opacity', 1)
            .style('transform', 'scale(1.05)');
    }

    handleSunburstOut(event, d) {
        d3.select(this)
            .transition()
            .duration(200)
            .style('opacity', 0.8)
            .style('transform', 'scale(1)');
    }

    handleHeatmapHover(event, d) {
        const tooltip = d3.select('body')
            .append('div')
            .attr('class', 'tooltip')
            .style('position', 'absolute')
            .style('background', 'white')
            .style('padding', '5px')
            .style('border', '1px solid #ddd')
            .html(`Value: ${d.value}`);

        tooltip
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px');
    }

    // Utility Methods
    dragBehavior(simulation) {
        return d3.drag()
            .on('start', (event, d) => {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            })
            .on('drag', (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on('end', (event, d) => {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            });
    }

    // Update Methods
    updateSunburst(svg, newData, options) {
        // Implementation for updating sunburst chart
    }

    updateHeatmap(svg, newData, options) {
        // Implementation for updating heatmap
    }

    updateNetwork(simulation, newData) {
        // Implementation for updating network graph
    }
}

// Initialize Advanced Visualization Manager
const advancedVisualizationManager = new AdvancedVisualizationManager();

// Export Manager
export { advancedVisualizationManager };

// Advanced Interactive Visualization System
class InteractiveVisualizationManager {
    constructor() {
        this.interactionHandlers = new Map();
        this.animationEffects = new Map();
        this.dataProcessors = new Map();
        this.visualEffects = new Map();
        this.initializeSystem();
    }

    // Initialize System Components
    initializeSystem() {
        this.initializeInteractions();
        this.initializeAnimations();
        this.initializeDataProcessors();
        this.initializeVisualEffects();
    }

    // Advanced Interaction Handlers
    initializeInteractions() {
        // Zoom and Pan Handler
        this.interactionHandlers.set('zoomPan', {
            initialize: (svg, options = {}) => {
                const zoom = d3.zoom()
                    .scaleExtent([options.minZoom || 0.5, options.maxZoom || 5])
                    .on('zoom', (event) => {
                        svg.select('.zoom-group')
                            .attr('transform', event.transform);
                    });

                svg.call(zoom);
                return zoom;
            },

            reset: (svg, zoom) => {
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);
            }
        });

        // Brush Selection Handler
        this.interactionHandlers.set('brush', {
            initialize: (svg, options = {}) => {
                const brush = d3.brush()
                    .extent([[0, 0], [options.width, options.height]])
                    .on('brush', (event) => {
                        this.handleBrushSelection(event, options.onBrush);
                    })
                    .on('end', (event) => {
                        this.handleBrushEnd(event, options.onBrushEnd);
                    });

                svg.append('g')
                    .attr('class', 'brush')
                    .call(brush);

                return brush;
            }
        });

        // Tooltip System
        this.interactionHandlers.set('tooltip', {
            create: (container, options = {}) => {
                const tooltip = d3.select(container)
                    .append('div')
                    .attr('class', 'visualization-tooltip')
                    .style('position', 'absolute')
                    .style('visibility', 'hidden')
                    .style('background', options.background || 'rgba(0, 0, 0, 0.8)')
                    .style('color', options.color || 'white')
                    .style('padding', options.padding || '8px')
                    .style('border-radius', options.borderRadius || '4px')
                    .style('font-size', options.fontSize || '12px')
                    .style('pointer-events', 'none')
                    .style('z-index', '1000');

                return {
                    show: (html, event) => {
                        tooltip
                            .html(html)
                            .style('visibility', 'visible')
                            .style('left', `${event.pageX + 10}px`)
                            .style('top', `${event.pageY - 10}px`);
                    },
                    hide: () => {
                        tooltip.style('visibility', 'hidden');
                    }
                };
            }
        });

        // Context Menu
        this.interactionHandlers.set('contextMenu', {
            create: (options = {}) => {
                const menu = d3.select('body')
                    .append('div')
                    .attr('class', 'context-menu')
                    .style('position', 'absolute')
                    .style('visibility', 'hidden')
                    .style('background', 'white')
                    .style('border', '1px solid #ddd')
                    .style('border-radius', '4px')
                    .style('box-shadow', '0 2px 5px rgba(0,0,0,0.2)');

                return {
                    show: (items, event) => {
                        menu.html('')
                            .selectAll('div')
                            .data(items)
                            .enter()
                            .append('div')
                            .style('padding', '8px 12px')
                            .style('cursor', 'pointer')
                            .style('hover', 'background: #f5f5f5')
                            .text(d => d.label)
                            .on('click', (e, d) => {
                                d.action();
                                menu.style('visibility', 'hidden');
                            });

                        menu.style('visibility', 'visible')
                            .style('left', `${event.pageX}px`)
                            .style('top', `${event.pageY}px`);

                        d3.select('body').on('click', () => {
                            menu.style('visibility', 'hidden');
                        });
                    },
                    hide: () => {
                        menu.style('visibility', 'hidden');
                    }
                };
            }
        });
    }

    // Advanced Animation Effects
    initializeAnimations() {
        // Transition Effects
        this.animationEffects.set('transitions', {
            fadeIn: (element, duration = 750) => {
                element
                    .style('opacity', 0)
                    .transition()
                    .duration(duration)
                    .style('opacity', 1);
            },

            slideIn: (element, direction = 'left', duration = 750) => {
                const x = direction === 'left' ? -100 : 
                         direction === 'right' ? 100 : 0;
                const y = direction === 'top' ? -100 : 
                         direction === 'bottom' ? 100 : 0;

                element
                    .style('transform', `translate(${x}px, ${y}px)`)
                    .style('opacity', 0)
                    .transition()
                    .duration(duration)
                    .style('transform', 'translate(0, 0)')
                    .style('opacity', 1);
            },

            scale: (element, duration = 750) => {
                element
                    .style('transform', 'scale(0)')
                    .transition()
                    .duration(duration)
                    .style('transform', 'scale(1)');
            }
        });

        // Path Animations
        this.animationEffects.set('paths', {
            draw: (path, duration = 1000) => {
                const length = path.node().getTotalLength();
                path
                    .attr('stroke-dasharray', length + ' ' + length)
                    .attr('stroke-dashoffset', length)
                    .transition()
                    .duration(duration)
                    .attr('stroke-dashoffset', 0);
            },

            dash: (path, duration = 1000) => {
                path
                    .attr('stroke-dasharray', '5,5')
                    .attr('stroke-dashoffset', '0')
                    .transition()
                    .duration(duration)
                    .attr('stroke-dashoffset', '20');
            }
        });

        // Chart Animations
        this.animationEffects.set('charts', {
            barGrow: (bars, duration = 750) => {
                bars
                    .attr('y', d => d.y1)
                    .attr('height', 0)
                    .transition()
                    .duration(duration)
                    .attr('y', d => d.y0)
                    .attr('height', d => d.y1 - d.y0);
            },

            pieSlice: (arcs, duration = 750) => {
                arcs
                    .transition()
                    .duration(duration)
                    .attrTween('d', function(d) {
                        const interpolate = d3.interpolate(
                            { startAngle: 0, endAngle: 0 },
                            { startAngle: d.startAngle, endAngle: d.endAngle }
                        );
                        return t => arc(interpolate(t));
                    });
            }
        });
    }

    // Data Processors
    initializeDataProcessors() {
        // Data Transformation
        this.dataProcessors.set('transform', {
            normalize: (data, field) => {
                const max = d3.max(data, d => d[field]);
                return data.map(d => ({
                    ...d,
                    [field]: d[field] / max
                }));
            },

            aggregate: (data, groupBy, metric) => {
                return d3.group(data, d => d[groupBy])
                    .map((group, key) => ({
                        key,
                        value: d3.sum(group, d => d[metric])
                    }));
            },

            pivot: (data, rows, cols, values) => {
                const pivot = {};
                data.forEach(d => {
                    if (!pivot[d[rows]]) pivot[d[rows]] = {};
                    pivot[d[rows]][d[cols]] = d[values];
                });
                return pivot;
            }
        });

        // Data Filtering
        this.dataProcessors.set('filter', {
            range: (data, field, min, max) => {
                return data.filter(d => d[field] >= min && d[field] <= max);
            },

            threshold: (data, field, threshold, comparison = '>') => {
                const compare = {
                    '>': (a, b) => a > b,
                    '<': (a, b) => a < b,
                    '>=': (a, b) => a >= b,
                    '<=': (a, b) => a <= b,
                    '=': (a, b) => a === b
                };
                return data.filter(d => compare[comparison](d[field], threshold));
            }
        });

        // Data Analysis
        this.dataProcessors.set('analyze', {
            statistics: (data, field) => {
                return {
                    mean: d3.mean(data, d => d[field]),
                    median: d3.median(data, d => d[field]),
                    std: d3.deviation(data, d => d[field]),
                    min: d3.min(data, d => d[field]),
                    max: d3.max(data, d => d[field])
                };
            },

            correlation: (data, field1, field2) => {
                const x = data.map(d => d[field1]);
                const y = data.map(d => d[field2]);
                return d3.correlation(x, y);
            }
        });
    }

    // Visual Effects
    initializeVisualEffects() {
        // Gradients
        this.visualEffects.set('gradients', {
            linear: (defs, id, colors) => {
                const gradient = defs.append('linearGradient')
                    .attr('id', id)
                    .attr('x1', '0%')
                    .attr('y1', '0%')
                    .attr('x2', '100%')
                    .attr('y2', '0%');

                colors.forEach((color, i) => {
                    gradient.append('stop')
                        .attr('offset', `${(i / (colors.length - 1)) * 100}%`)
                        .attr('stop-color', color);
                });

                return gradient;
            },

            radial: (defs, id, colors) => {
                const gradient = defs.append('radialGradient')
                    .attr('id', id)
                    .attr('cx', '50%')
                    .attr('cy', '50%')
                    .attr('r', '50%');

                colors.forEach((color, i) => {
                    gradient.append('stop')
                        .attr('offset', `${(i / (colors.length - 1)) * 100}%`)
                        .attr('stop-color', color);
                });

                return gradient;
            }
        });

        // Patterns
        this.visualEffects.set('patterns', {
            stripes: (defs, id, color) => {
                const pattern = defs.append('pattern')
                    .attr('id', id)
                    .attr('patternUnits', 'userSpaceOnUse')
                    .attr('width', 10)
                    .attr('height', 10);

                pattern.append('path')
                    .attr('d', 'M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2')
                    .attr('stroke', color)
                    .attr('stroke-width', 2);

                return pattern;
            },

            dots: (defs, id, color) => {
                const pattern = defs.append('pattern')
                    .attr('id', id)
                    .attr('patternUnits', 'userSpaceOnUse')
                    .attr('width', 10)
                    .attr('height', 10);

                pattern.append('circle')
                    .attr('cx', 5)
                    .attr('cy', 5)
                    .attr('r', 2)
                    .attr('fill', color);

                return pattern;
            }
        });

        // Filters
        this.visualEffects.set('filters', {
            glow: (defs, id, color) => {
                const filter = defs.append('filter')
                    .attr('id', id);

                filter.append('feGaussianBlur')
                    .attr('stdDeviation', 3)
                    .attr('result', 'coloredBlur');

                const feMerge = filter.append('feMerge');
                feMerge.append('feMergeNode')
                    .attr('in', 'coloredBlur');
                feMerge.append('feMergeNode')
                    .attr('in', 'SourceGraphic');

                return filter;
            },

            shadow: (defs, id) => {
                const filter = defs.append('filter')
                    .attr('id', id)
                    .attr('x', '-50%')
                    .attr('y', '-50%')
                    .attr('width', '200%')
                    .attr('height', '200%');

                filter.append('feOffset')
                    .attr('result', 'offOut')
                    .attr('in', 'SourceAlpha')
                    .attr('dx', 3)
                    .attr('dy', 3);

                filter.append('feGaussianBlur')
                    .attr('result', 'blurOut')
                    .attr('in', 'offOut')
                    .attr('stdDeviation', 3);

                filter.append('feBlend')
                    .attr('in', 'SourceGraphic')
                    .attr('in2', 'blurOut')
                    .attr('mode', 'normal');

                return filter;
            }
        });
    }
}

// Initialize Interactive Visualization Manager
const interactiveVisualizationManager = new InteractiveVisualizationManager();

// Export Manager
export { interactiveVisualizationManager };  
     // Advanced Visualization Components and Analysis Tools
class AdvancedVisualizationComponents {
    constructor() {
        this.customCharts = new Map();
        this.analysisTools = new Map();
        this.components = new Map();
        this.initializeComponents();
    }

    // Initialize All Components
    initializeComponents() {
        this.initializeCustomCharts();
        this.initializeAnalysisTools();
        this.initializeComponents();
    }

    // Custom Chart Types
    initializeCustomCharts() {
        // Radar/Spider Chart
        this.customCharts.set('radar', {
            create: (container, data, options = {}) => {
                const width = options.width || 600;
                const height = options.height || 600;
                const radius = Math.min(width, height) / 2;
                const angleSlice = (Math.PI * 2) / data.axes.length;

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g')
                    .attr('transform', `translate(${width/2},${height/2})`);

                // Scale for the radius
                const rScale = d3.scaleLinear()
                    .range([0, radius])
                    .domain([0, d3.max(data.values, d => d3.max(d.values))]);

                // Draw the circular grid
                this.drawRadarGrid(svg, radius, data.axes.length, angleSlice);

                // Draw the axes
                this.drawRadarAxes(svg, data.axes, radius, angleSlice);

                // Draw the path
                this.drawRadarPath(svg, data.values, rScale, angleSlice);

                return svg;
            }
        });

        // Bubble Timeline
        this.customCharts.set('bubbleTimeline', {
            create: (container, data, options = {}) => {
                const width = options.width || 800;
                const height = options.height || 400;
                const margin = options.margin || { top: 20, right: 20, bottom: 30, left: 40 };

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const x = d3.scaleTime()
                    .domain(d3.extent(data, d => d.date))
                    .range([margin.left, width - margin.right]);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.value)])
                    .range([height - margin.bottom, margin.top]);

                const r = d3.scaleSqrt()
                    .domain([0, d3.max(data, d => d.size)])
                    .range([2, 20]);

                this.drawBubbleTimelinePath(svg, data, x, y);
                this.drawBubbleTimelineBubbles(svg, data, x, y, r);

                return svg;
            }
        });

        // Hierarchical Edge Bundling
        this.customCharts.set('edgeBundling', {
            create: (container, data, options = {}) => {
                const width = options.width || 800;
                const height = options.height || 800;
                const radius = width / 2;

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g')
                    .attr('transform', `translate(${width/2},${height/2})`);

                const cluster = d3.cluster()
                    .size([360, radius - 60]);

                const root = d3.hierarchy(data);
                cluster(root);

                this.drawEdgeBundlingLinks(svg, root, radius);
                this.drawEdgeBundlingNodes(svg, root);

                return svg;
            }
        });

        // Stream Graph
        this.customCharts.set('streamGraph', {
            create: (container, data, options = {}) => {
                const width = options.width || 800;
                const height = options.height || 400;
                const margin = options.margin || { top: 20, right: 20, bottom: 30, left: 40 };

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const stack = d3.stack()
                    .offset(d3.stackOffsetWiggle)
                    .keys(data.columns);

                const layers = stack(data);

                const x = d3.scaleTime()
                    .domain(d3.extent(data, d => d.date))
                    .range([margin.left, width - margin.right]);

                const y = d3.scaleLinear()
                    .domain([d3.min(layers, l => d3.min(l, d => d[0])),
                            d3.max(layers, l => d3.max(l, d => d[1]))])
                    .range([height - margin.bottom, margin.top]);

                const area = d3.area()
                    .x(d => x(d.data.date))
                    .y0(d => y(d[0]))
                    .y1(d => y(d[1]))
                    .curve(d3.curveBasis);

                this.drawStreamGraphLayers(svg, layers, area);

                return svg;
            }
        });
    }

    // Analysis Tools
    initializeAnalysisTools() {
        // Trend Analysis
        this.analysisTools.set('trendAnalysis', {
            analyze: (data, options = {}) => {
                const xValues = data.map((d, i) => i);
                const yValues = data.map(d => d.value);

                // Linear regression
                const regression = this.calculateLinearRegression(xValues, yValues);

                // Moving average
                const movingAvg = this.calculateMovingAverage(yValues, options.window || 5);

                // Seasonality detection
                const seasonality = this.detectSeasonality(yValues);

                return {
                    trend: regression,
                    movingAverage: movingAvg,
                    seasonality: seasonality
                };
            }
        });

        // Pattern Detection
        this.analysisTools.set('patternDetection', {
            analyze: (data, options = {}) => {
                // Anomaly detection
                const anomalies = this.detectAnomalies(data, options.threshold);

                // Pattern matching
                const patterns = this.findPatterns(data, options.patternLength);

                // Cycle detection
                const cycles = this.detectCycles(data);

                return {
                    anomalies,
                    patterns,
                    cycles
                };
            }
        });

        // Correlation Analysis
        this.analysisTools.set('correlationAnalysis', {
            analyze: (dataset, options = {}) => {
                const correlations = new Map();
                const variables = Object.keys(dataset[0]);

                for (let i = 0; i < variables.length; i++) {
                    for (let j = i + 1; j < variables.length; j++) {
                        const var1 = variables[i];
                        const var2 = variables[j];
                        
                        const correlation = this.calculateCorrelation(
                            dataset.map(d => d[var1]),
                            dataset.map(d => d[var2])
                        );

                        correlations.set(`${var1}-${var2}`, correlation);
                    }
                }

                return correlations;
            }
        });
    }

    // Custom Components
    initializeCustomComponents() {
        // Custom Legend
        this.components.set('legend', {
            create: (container, data, options = {}) => {
                const legend = d3.select(container)
                    .append('div')
                    .attr('class', 'custom-legend')
                    .style('display', 'flex')
                    .style('flex-direction', options.direction || 'horizontal')
                    .style('gap', '10px')
                    .style('padding', '10px');

                const items = legend.selectAll('.legend-item')
                    .data(data)
                    .enter()
                    .append('div')
                    .attr('class', 'legend-item')
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('gap', '5px')
                    .style('cursor', 'pointer')
                    .on('click', (event, d) => {
                        if (options.onClick) options.onClick(d);
                    });

                items.append('div')
                    .style('width', '12px')
                    .style('height', '12px')
                    .style('background-color', d => d.color)
                    .style('border-radius', '2px');

                items.append('span')
                    .text(d => d.label);

                return legend;
            }
        });

        // Data Table
        this.components.set('dataTable', {
            create: (container, data, options = {}) => {
                const table = d3.select(container)
                    .append('table')
                    .attr('class', 'data-table');

                // Headers
                const headers = table.append('thead')
                    .append('tr')
                    .selectAll('th')
                    .data(options.columns)
                    .enter()
                    .append('th')
                    .text(d => d.label)
                    .style('cursor', 'pointer')
                    .on('click', (event, d) => {
                        if (options.onSort) options.onSort(d.key);
                    });

                // Rows
                const rows = table.append('tbody')
                    .selectAll('tr')
                    .data(data)
                    .enter()
                    .append('tr');

                // Cells
                rows.selectAll('td')
                    .data(d => options.columns.map(col => d[col.key]))
                    .enter()
                    .append('td')
                    .text(d => d);

                return table;
            }
        });

        // Control Panel
        this.components.set('controlPanel', {
            create: (container, controls, options = {}) => {
                const panel = d3.select(container)
                    .append('div')
                    .attr('class', 'control-panel')
                    .style('padding', '15px')
                    .style('background', '#f5f5f5')
                    .style('border-radius', '8px');

                controls.forEach(control => {
                    const controlGroup = panel.append('div')
                        .style('margin-bottom', '10px');

                    controlGroup.append('label')
                        .text(control.label);

                    switch (control.type) {
                        case 'select':
                            this.createSelect(controlGroup, control);
                            break;
                        case 'range':
                            this.createRange(controlGroup, control);
                            break;
                        case 'checkbox':
                            this.createCheckbox(controlGroup, control);
                            break;
                        case 'radio':
                            this.createRadio(controlGroup, control);
                            break;
                    }
                });

                return panel;
            }
        });
    }

    // Utility Methods
    calculateLinearRegression(x, y) {
        const n = x.length;
        const xy = x.map((xi, i) => xi * y[i]);
        const xx = x.map(xi => xi * xi);

        const slope = (n * d3.sum(xy) - d3.sum(x) * d3.sum(y)) / 
                     (n * d3.sum(xx) - d3.sum(x) * d3.sum(x));
        const intercept = (d3.sum(y) - slope * d3.sum(x)) / n;

        return { slope, intercept };
    }

    calculateMovingAverage(values, window) {
        const result = [];
        for (let i = 0; i < values.length - window + 1; i++) {
            const windowValues = values.slice(i, i + window);
            result.push(d3.mean(windowValues));
        }
        return result;
    }

    detectSeasonality(values) {
        // Implementation of seasonality detection
        // Using autocorrelation or other statistical methods
    }

    calculateCorrelation(x, y) {
        const n = x.length;
        const mean_x = d3.mean(x);
        const mean_y = d3.mean(y);
        const std_x = d3.deviation(x);
        const std_y = d3.deviation(y);

        const sum = x.reduce((acc, xi, i) => {
            return acc + ((xi - mean_x) * (y[i] - mean_y)) / (std_x * std_y);
        }, 0);

        return sum / (n - 1);
    }
}

// Initialize Advanced Visualization Components
const advancedVisualizationComponents = new AdvancedVisualizationComponents();

// Export Components
export { advancedVisualizationComponents };
</script>
</html>
